// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dex/sol/v1/core.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dex_2fsol_2fv1_2fcore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dex_2fsol_2fv1_2fcore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dex_2fsol_2fv1_2fcore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dex_2fsol_2fv1_2fcore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dex_2fsol_2fv1_2fcore_2eproto;
namespace dex {
namespace sol {
namespace v1 {
class BlockHead;
struct BlockHeadDefaultTypeInternal;
extern BlockHeadDefaultTypeInternal _BlockHead_default_instance_;
class Candle;
struct CandleDefaultTypeInternal;
extern CandleDefaultTypeInternal _Candle_default_instance_;
class PoolSnapshot;
struct PoolSnapshotDefaultTypeInternal;
extern PoolSnapshotDefaultTypeInternal _PoolSnapshot_default_instance_;
class SwapEvent;
struct SwapEventDefaultTypeInternal;
extern SwapEventDefaultTypeInternal _SwapEvent_default_instance_;
class TxMeta;
struct TxMetaDefaultTypeInternal;
extern TxMetaDefaultTypeInternal _TxMeta_default_instance_;
class U128;
struct U128DefaultTypeInternal;
extern U128DefaultTypeInternal _U128_default_instance_;
class WalletHeuristics;
struct WalletHeuristicsDefaultTypeInternal;
extern WalletHeuristicsDefaultTypeInternal _WalletHeuristics_default_instance_;
}  // namespace v1
}  // namespace sol
}  // namespace dex
PROTOBUF_NAMESPACE_OPEN
template<> ::dex::sol::v1::BlockHead* Arena::CreateMaybeMessage<::dex::sol::v1::BlockHead>(Arena*);
template<> ::dex::sol::v1::Candle* Arena::CreateMaybeMessage<::dex::sol::v1::Candle>(Arena*);
template<> ::dex::sol::v1::PoolSnapshot* Arena::CreateMaybeMessage<::dex::sol::v1::PoolSnapshot>(Arena*);
template<> ::dex::sol::v1::SwapEvent* Arena::CreateMaybeMessage<::dex::sol::v1::SwapEvent>(Arena*);
template<> ::dex::sol::v1::TxMeta* Arena::CreateMaybeMessage<::dex::sol::v1::TxMeta>(Arena*);
template<> ::dex::sol::v1::U128* Arena::CreateMaybeMessage<::dex::sol::v1::U128>(Arena*);
template<> ::dex::sol::v1::WalletHeuristics* Arena::CreateMaybeMessage<::dex::sol::v1::WalletHeuristics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dex {
namespace sol {
namespace v1 {

// ===================================================================

class U128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.U128) */ {
 public:
  inline U128() : U128(nullptr) {}
  ~U128() override;
  explicit PROTOBUF_CONSTEXPR U128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  U128(const U128& from);
  U128(U128&& from) noexcept
    : U128() {
    *this = ::std::move(from);
  }

  inline U128& operator=(const U128& from) {
    CopyFrom(from);
    return *this;
  }
  inline U128& operator=(U128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const U128& default_instance() {
    return *internal_default_instance();
  }
  static inline const U128* internal_default_instance() {
    return reinterpret_cast<const U128*>(
               &_U128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(U128& a, U128& b) {
    a.Swap(&b);
  }
  inline void Swap(U128* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(U128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  U128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<U128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const U128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const U128& from) {
    U128::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(U128* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.U128";
  }
  protected:
  explicit U128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // uint64 hi = 1;
  void clear_hi();
  uint64_t hi() const;
  void set_hi(uint64_t value);
  private:
  uint64_t _internal_hi() const;
  void _internal_set_hi(uint64_t value);
  public:

  // uint64 lo = 2;
  void clear_lo();
  uint64_t lo() const;
  void set_lo(uint64_t value);
  private:
  uint64_t _internal_lo() const;
  void _internal_set_lo(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.U128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hi_;
    uint64_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class BlockHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.BlockHead) */ {
 public:
  inline BlockHead() : BlockHead(nullptr) {}
  ~BlockHead() override;
  explicit PROTOBUF_CONSTEXPR BlockHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHead(const BlockHead& from);
  BlockHead(BlockHead&& from) noexcept
    : BlockHead() {
    *this = ::std::move(from);
  }

  inline BlockHead& operator=(const BlockHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHead& operator=(BlockHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHead* internal_default_instance() {
    return reinterpret_cast<const BlockHead*>(
               &_BlockHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlockHead& a, BlockHead& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockHead& from) {
    BlockHead::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.BlockHead";
  }
  protected:
  explicit BlockHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 4,
    kChainIdFieldNumber = 1,
    kSlotFieldNumber = 2,
    kTsSecFieldNumber = 3,
  };
  // string status = 4;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 slot = 2;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // uint64 ts_sec = 3;
  void clear_ts_sec();
  uint64_t ts_sec() const;
  void set_ts_sec(uint64_t value);
  private:
  uint64_t _internal_ts_sec() const;
  void _internal_set_ts_sec(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.BlockHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    uint64_t chain_id_;
    uint64_t slot_;
    uint64_t ts_sec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class TxMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.TxMeta) */ {
 public:
  inline TxMeta() : TxMeta(nullptr) {}
  ~TxMeta() override;
  explicit PROTOBUF_CONSTEXPR TxMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxMeta(const TxMeta& from);
  TxMeta(TxMeta&& from) noexcept
    : TxMeta() {
    *this = ::std::move(from);
  }

  inline TxMeta& operator=(const TxMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxMeta& operator=(TxMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxMeta* internal_default_instance() {
    return reinterpret_cast<const TxMeta*>(
               &_TxMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TxMeta& a, TxMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TxMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxMeta& from) {
    TxMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.TxMeta";
  }
  protected:
  explicit TxMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogMsgsFieldNumber = 7,
    kSigFieldNumber = 3,
    kChainIdFieldNumber = 1,
    kSlotFieldNumber = 2,
    kCuUsedFieldNumber = 5,
    kCuPriceFieldNumber = 6,
    kSuccessFieldNumber = 4,
  };
  // repeated string log_msgs = 7;
  int log_msgs_size() const;
  private:
  int _internal_log_msgs_size() const;
  public:
  void clear_log_msgs();
  const std::string& log_msgs(int index) const;
  std::string* mutable_log_msgs(int index);
  void set_log_msgs(int index, const std::string& value);
  void set_log_msgs(int index, std::string&& value);
  void set_log_msgs(int index, const char* value);
  void set_log_msgs(int index, const char* value, size_t size);
  std::string* add_log_msgs();
  void add_log_msgs(const std::string& value);
  void add_log_msgs(std::string&& value);
  void add_log_msgs(const char* value);
  void add_log_msgs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& log_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_log_msgs();
  private:
  const std::string& _internal_log_msgs(int index) const;
  std::string* _internal_add_log_msgs();
  public:

  // string sig = 3;
  void clear_sig();
  const std::string& sig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig();
  PROTOBUF_NODISCARD std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 slot = 2;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // uint64 cu_used = 5;
  void clear_cu_used();
  uint64_t cu_used() const;
  void set_cu_used(uint64_t value);
  private:
  uint64_t _internal_cu_used() const;
  void _internal_set_cu_used(uint64_t value);
  public:

  // uint64 cu_price = 6;
  void clear_cu_price();
  uint64_t cu_price() const;
  void set_cu_price(uint64_t value);
  private:
  uint64_t _internal_cu_price() const;
  void _internal_set_cu_price(uint64_t value);
  public:

  // bool success = 4;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.TxMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> log_msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
    uint64_t chain_id_;
    uint64_t slot_;
    uint64_t cu_used_;
    uint64_t cu_price_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class SwapEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.SwapEvent) */ {
 public:
  inline SwapEvent() : SwapEvent(nullptr) {}
  ~SwapEvent() override;
  explicit PROTOBUF_CONSTEXPR SwapEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwapEvent(const SwapEvent& from);
  SwapEvent(SwapEvent&& from) noexcept
    : SwapEvent() {
    *this = ::std::move(from);
  }

  inline SwapEvent& operator=(const SwapEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapEvent& operator=(SwapEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwapEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwapEvent* internal_default_instance() {
    return reinterpret_cast<const SwapEvent*>(
               &_SwapEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SwapEvent& a, SwapEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwapEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwapEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwapEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwapEvent& from) {
    SwapEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.SwapEvent";
  }
  protected:
  explicit SwapEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 3,
    kProgramIdFieldNumber = 5,
    kPoolIdFieldNumber = 6,
    kMintBaseFieldNumber = 7,
    kMintQuoteFieldNumber = 8,
    kChainIdFieldNumber = 1,
    kSlotFieldNumber = 2,
    kIndexFieldNumber = 4,
    kDecBaseFieldNumber = 9,
    kBaseInFieldNumber = 11,
    kBaseOutFieldNumber = 12,
    kQuoteInFieldNumber = 13,
    kQuoteOutFieldNumber = 14,
    kDecQuoteFieldNumber = 10,
    kFeeBpsFieldNumber = 19,
    kSqrtPriceQ64PreFieldNumber = 15,
    kSqrtPriceQ64PostFieldNumber = 16,
    kReservesBaseFieldNumber = 17,
    kReservesQuoteFieldNumber = 18,
    kProvisionalFieldNumber = 20,
    kIsUndoFieldNumber = 21,
  };
  // string sig = 3;
  void clear_sig();
  const std::string& sig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sig();
  PROTOBUF_NODISCARD std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // string program_id = 5;
  void clear_program_id();
  const std::string& program_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_program_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_program_id();
  PROTOBUF_NODISCARD std::string* release_program_id();
  void set_allocated_program_id(std::string* program_id);
  private:
  const std::string& _internal_program_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_program_id(const std::string& value);
  std::string* _internal_mutable_program_id();
  public:

  // string pool_id = 6;
  void clear_pool_id();
  const std::string& pool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pool_id();
  PROTOBUF_NODISCARD std::string* release_pool_id();
  void set_allocated_pool_id(std::string* pool_id);
  private:
  const std::string& _internal_pool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pool_id(const std::string& value);
  std::string* _internal_mutable_pool_id();
  public:

  // string mint_base = 7;
  void clear_mint_base();
  const std::string& mint_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mint_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mint_base();
  PROTOBUF_NODISCARD std::string* release_mint_base();
  void set_allocated_mint_base(std::string* mint_base);
  private:
  const std::string& _internal_mint_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mint_base(const std::string& value);
  std::string* _internal_mutable_mint_base();
  public:

  // string mint_quote = 8;
  void clear_mint_quote();
  const std::string& mint_quote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mint_quote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mint_quote();
  PROTOBUF_NODISCARD std::string* release_mint_quote();
  void set_allocated_mint_quote(std::string* mint_quote);
  private:
  const std::string& _internal_mint_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mint_quote(const std::string& value);
  std::string* _internal_mutable_mint_quote();
  public:

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 slot = 2;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // uint32 index = 4;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // uint32 dec_base = 9;
  void clear_dec_base();
  uint32_t dec_base() const;
  void set_dec_base(uint32_t value);
  private:
  uint32_t _internal_dec_base() const;
  void _internal_set_dec_base(uint32_t value);
  public:

  // uint64 base_in = 11;
  void clear_base_in();
  uint64_t base_in() const;
  void set_base_in(uint64_t value);
  private:
  uint64_t _internal_base_in() const;
  void _internal_set_base_in(uint64_t value);
  public:

  // uint64 base_out = 12;
  void clear_base_out();
  uint64_t base_out() const;
  void set_base_out(uint64_t value);
  private:
  uint64_t _internal_base_out() const;
  void _internal_set_base_out(uint64_t value);
  public:

  // uint64 quote_in = 13;
  void clear_quote_in();
  uint64_t quote_in() const;
  void set_quote_in(uint64_t value);
  private:
  uint64_t _internal_quote_in() const;
  void _internal_set_quote_in(uint64_t value);
  public:

  // uint64 quote_out = 14;
  void clear_quote_out();
  uint64_t quote_out() const;
  void set_quote_out(uint64_t value);
  private:
  uint64_t _internal_quote_out() const;
  void _internal_set_quote_out(uint64_t value);
  public:

  // uint32 dec_quote = 10;
  void clear_dec_quote();
  uint32_t dec_quote() const;
  void set_dec_quote(uint32_t value);
  private:
  uint32_t _internal_dec_quote() const;
  void _internal_set_dec_quote(uint32_t value);
  public:

  // uint32 fee_bps = 19;
  void clear_fee_bps();
  uint32_t fee_bps() const;
  void set_fee_bps(uint32_t value);
  private:
  uint32_t _internal_fee_bps() const;
  void _internal_set_fee_bps(uint32_t value);
  public:

  // uint64 sqrt_price_q64_pre = 15;
  void clear_sqrt_price_q64_pre();
  uint64_t sqrt_price_q64_pre() const;
  void set_sqrt_price_q64_pre(uint64_t value);
  private:
  uint64_t _internal_sqrt_price_q64_pre() const;
  void _internal_set_sqrt_price_q64_pre(uint64_t value);
  public:

  // uint64 sqrt_price_q64_post = 16;
  void clear_sqrt_price_q64_post();
  uint64_t sqrt_price_q64_post() const;
  void set_sqrt_price_q64_post(uint64_t value);
  private:
  uint64_t _internal_sqrt_price_q64_post() const;
  void _internal_set_sqrt_price_q64_post(uint64_t value);
  public:

  // uint64 reserves_base = 17;
  void clear_reserves_base();
  uint64_t reserves_base() const;
  void set_reserves_base(uint64_t value);
  private:
  uint64_t _internal_reserves_base() const;
  void _internal_set_reserves_base(uint64_t value);
  public:

  // uint64 reserves_quote = 18;
  void clear_reserves_quote();
  uint64_t reserves_quote() const;
  void set_reserves_quote(uint64_t value);
  private:
  uint64_t _internal_reserves_quote() const;
  void _internal_set_reserves_quote(uint64_t value);
  public:

  // bool provisional = 20;
  void clear_provisional();
  bool provisional() const;
  void set_provisional(bool value);
  private:
  bool _internal_provisional() const;
  void _internal_set_provisional(bool value);
  public:

  // bool is_undo = 21;
  void clear_is_undo();
  bool is_undo() const;
  void set_is_undo(bool value);
  private:
  bool _internal_is_undo() const;
  void _internal_set_is_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.SwapEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr program_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pool_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mint_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mint_quote_;
    uint64_t chain_id_;
    uint64_t slot_;
    uint32_t index_;
    uint32_t dec_base_;
    uint64_t base_in_;
    uint64_t base_out_;
    uint64_t quote_in_;
    uint64_t quote_out_;
    uint32_t dec_quote_;
    uint32_t fee_bps_;
    uint64_t sqrt_price_q64_pre_;
    uint64_t sqrt_price_q64_post_;
    uint64_t reserves_base_;
    uint64_t reserves_quote_;
    bool provisional_;
    bool is_undo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class PoolSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.PoolSnapshot) */ {
 public:
  inline PoolSnapshot() : PoolSnapshot(nullptr) {}
  ~PoolSnapshot() override;
  explicit PROTOBUF_CONSTEXPR PoolSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PoolSnapshot(const PoolSnapshot& from);
  PoolSnapshot(PoolSnapshot&& from) noexcept
    : PoolSnapshot() {
    *this = ::std::move(from);
  }

  inline PoolSnapshot& operator=(const PoolSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoolSnapshot& operator=(PoolSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoolSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoolSnapshot* internal_default_instance() {
    return reinterpret_cast<const PoolSnapshot*>(
               &_PoolSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PoolSnapshot& a, PoolSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(PoolSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoolSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoolSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoolSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PoolSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PoolSnapshot& from) {
    PoolSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoolSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.PoolSnapshot";
  }
  protected:
  explicit PoolSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolIdFieldNumber = 3,
    kMintBaseFieldNumber = 4,
    kMintQuoteFieldNumber = 5,
    kChainIdFieldNumber = 1,
    kSlotFieldNumber = 2,
    kSqrtPriceQ64FieldNumber = 6,
    kReservesBaseFieldNumber = 7,
    kReservesQuoteFieldNumber = 8,
    kLiquidityFieldNumber = 10,
    kFeeBpsFieldNumber = 9,
  };
  // string pool_id = 3;
  void clear_pool_id();
  const std::string& pool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pool_id();
  PROTOBUF_NODISCARD std::string* release_pool_id();
  void set_allocated_pool_id(std::string* pool_id);
  private:
  const std::string& _internal_pool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pool_id(const std::string& value);
  std::string* _internal_mutable_pool_id();
  public:

  // string mint_base = 4;
  void clear_mint_base();
  const std::string& mint_base() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mint_base(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mint_base();
  PROTOBUF_NODISCARD std::string* release_mint_base();
  void set_allocated_mint_base(std::string* mint_base);
  private:
  const std::string& _internal_mint_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mint_base(const std::string& value);
  std::string* _internal_mutable_mint_base();
  public:

  // string mint_quote = 5;
  void clear_mint_quote();
  const std::string& mint_quote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mint_quote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mint_quote();
  PROTOBUF_NODISCARD std::string* release_mint_quote();
  void set_allocated_mint_quote(std::string* mint_quote);
  private:
  const std::string& _internal_mint_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mint_quote(const std::string& value);
  std::string* _internal_mutable_mint_quote();
  public:

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 slot = 2;
  void clear_slot();
  uint64_t slot() const;
  void set_slot(uint64_t value);
  private:
  uint64_t _internal_slot() const;
  void _internal_set_slot(uint64_t value);
  public:

  // uint64 sqrt_price_q64 = 6;
  void clear_sqrt_price_q64();
  uint64_t sqrt_price_q64() const;
  void set_sqrt_price_q64(uint64_t value);
  private:
  uint64_t _internal_sqrt_price_q64() const;
  void _internal_set_sqrt_price_q64(uint64_t value);
  public:

  // uint64 reserves_base = 7;
  void clear_reserves_base();
  uint64_t reserves_base() const;
  void set_reserves_base(uint64_t value);
  private:
  uint64_t _internal_reserves_base() const;
  void _internal_set_reserves_base(uint64_t value);
  public:

  // uint64 reserves_quote = 8;
  void clear_reserves_quote();
  uint64_t reserves_quote() const;
  void set_reserves_quote(uint64_t value);
  private:
  uint64_t _internal_reserves_quote() const;
  void _internal_set_reserves_quote(uint64_t value);
  public:

  // uint64 liquidity = 10;
  void clear_liquidity();
  uint64_t liquidity() const;
  void set_liquidity(uint64_t value);
  private:
  uint64_t _internal_liquidity() const;
  void _internal_set_liquidity(uint64_t value);
  public:

  // uint32 fee_bps = 9;
  void clear_fee_bps();
  uint32_t fee_bps() const;
  void set_fee_bps(uint32_t value);
  private:
  uint32_t _internal_fee_bps() const;
  void _internal_set_fee_bps(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.PoolSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pool_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mint_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mint_quote_;
    uint64_t chain_id_;
    uint64_t slot_;
    uint64_t sqrt_price_q64_;
    uint64_t reserves_base_;
    uint64_t reserves_quote_;
    uint64_t liquidity_;
    uint32_t fee_bps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Candle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.Candle) */ {
 public:
  inline Candle() : Candle(nullptr) {}
  ~Candle() override;
  explicit PROTOBUF_CONSTEXPR Candle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Candle(const Candle& from);
  Candle(Candle&& from) noexcept
    : Candle() {
    *this = ::std::move(from);
  }

  inline Candle& operator=(const Candle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Candle& operator=(Candle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Candle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Candle* internal_default_instance() {
    return reinterpret_cast<const Candle*>(
               &_Candle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Candle& a, Candle& b) {
    a.Swap(&b);
  }
  inline void Swap(Candle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Candle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Candle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Candle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Candle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Candle& from) {
    Candle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Candle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.Candle";
  }
  protected:
  explicit Candle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPairIdFieldNumber = 2,
    kPoolIdFieldNumber = 3,
    kTimeframeFieldNumber = 4,
    kVwapNumFieldNumber = 14,
    kVwapDenFieldNumber = 15,
    kVolBaseFieldNumber = 16,
    kVolQuoteFieldNumber = 17,
    kChainIdFieldNumber = 1,
    kWindowStartFieldNumber = 5,
    kOpenPxQ32FieldNumber = 10,
    kProvisionalFieldNumber = 6,
    kIsCorrectionFieldNumber = 7,
    kTradesFieldNumber = 18,
    kHighPxQ32FieldNumber = 11,
    kLowPxQ32FieldNumber = 12,
    kClosePxQ32FieldNumber = 13,
  };
  // string pair_id = 2;
  void clear_pair_id();
  const std::string& pair_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pair_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pair_id();
  PROTOBUF_NODISCARD std::string* release_pair_id();
  void set_allocated_pair_id(std::string* pair_id);
  private:
  const std::string& _internal_pair_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pair_id(const std::string& value);
  std::string* _internal_mutable_pair_id();
  public:

  // string pool_id = 3;
  void clear_pool_id();
  const std::string& pool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pool_id();
  PROTOBUF_NODISCARD std::string* release_pool_id();
  void set_allocated_pool_id(std::string* pool_id);
  private:
  const std::string& _internal_pool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pool_id(const std::string& value);
  std::string* _internal_mutable_pool_id();
  public:

  // string timeframe = 4;
  void clear_timeframe();
  const std::string& timeframe() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timeframe(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timeframe();
  PROTOBUF_NODISCARD std::string* release_timeframe();
  void set_allocated_timeframe(std::string* timeframe);
  private:
  const std::string& _internal_timeframe() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeframe(const std::string& value);
  std::string* _internal_mutable_timeframe();
  public:

  // .dex.sol.v1.U128 vwap_num = 14;
  bool has_vwap_num() const;
  private:
  bool _internal_has_vwap_num() const;
  public:
  void clear_vwap_num();
  const ::dex::sol::v1::U128& vwap_num() const;
  PROTOBUF_NODISCARD ::dex::sol::v1::U128* release_vwap_num();
  ::dex::sol::v1::U128* mutable_vwap_num();
  void set_allocated_vwap_num(::dex::sol::v1::U128* vwap_num);
  private:
  const ::dex::sol::v1::U128& _internal_vwap_num() const;
  ::dex::sol::v1::U128* _internal_mutable_vwap_num();
  public:
  void unsafe_arena_set_allocated_vwap_num(
      ::dex::sol::v1::U128* vwap_num);
  ::dex::sol::v1::U128* unsafe_arena_release_vwap_num();

  // .dex.sol.v1.U128 vwap_den = 15;
  bool has_vwap_den() const;
  private:
  bool _internal_has_vwap_den() const;
  public:
  void clear_vwap_den();
  const ::dex::sol::v1::U128& vwap_den() const;
  PROTOBUF_NODISCARD ::dex::sol::v1::U128* release_vwap_den();
  ::dex::sol::v1::U128* mutable_vwap_den();
  void set_allocated_vwap_den(::dex::sol::v1::U128* vwap_den);
  private:
  const ::dex::sol::v1::U128& _internal_vwap_den() const;
  ::dex::sol::v1::U128* _internal_mutable_vwap_den();
  public:
  void unsafe_arena_set_allocated_vwap_den(
      ::dex::sol::v1::U128* vwap_den);
  ::dex::sol::v1::U128* unsafe_arena_release_vwap_den();

  // .dex.sol.v1.U128 vol_base = 16;
  bool has_vol_base() const;
  private:
  bool _internal_has_vol_base() const;
  public:
  void clear_vol_base();
  const ::dex::sol::v1::U128& vol_base() const;
  PROTOBUF_NODISCARD ::dex::sol::v1::U128* release_vol_base();
  ::dex::sol::v1::U128* mutable_vol_base();
  void set_allocated_vol_base(::dex::sol::v1::U128* vol_base);
  private:
  const ::dex::sol::v1::U128& _internal_vol_base() const;
  ::dex::sol::v1::U128* _internal_mutable_vol_base();
  public:
  void unsafe_arena_set_allocated_vol_base(
      ::dex::sol::v1::U128* vol_base);
  ::dex::sol::v1::U128* unsafe_arena_release_vol_base();

  // .dex.sol.v1.U128 vol_quote = 17;
  bool has_vol_quote() const;
  private:
  bool _internal_has_vol_quote() const;
  public:
  void clear_vol_quote();
  const ::dex::sol::v1::U128& vol_quote() const;
  PROTOBUF_NODISCARD ::dex::sol::v1::U128* release_vol_quote();
  ::dex::sol::v1::U128* mutable_vol_quote();
  void set_allocated_vol_quote(::dex::sol::v1::U128* vol_quote);
  private:
  const ::dex::sol::v1::U128& _internal_vol_quote() const;
  ::dex::sol::v1::U128* _internal_mutable_vol_quote();
  public:
  void unsafe_arena_set_allocated_vol_quote(
      ::dex::sol::v1::U128* vol_quote);
  ::dex::sol::v1::U128* unsafe_arena_release_vol_quote();

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 window_start = 5;
  void clear_window_start();
  uint64_t window_start() const;
  void set_window_start(uint64_t value);
  private:
  uint64_t _internal_window_start() const;
  void _internal_set_window_start(uint64_t value);
  public:

  // int64 open_px_q32 = 10;
  void clear_open_px_q32();
  int64_t open_px_q32() const;
  void set_open_px_q32(int64_t value);
  private:
  int64_t _internal_open_px_q32() const;
  void _internal_set_open_px_q32(int64_t value);
  public:

  // bool provisional = 6;
  void clear_provisional();
  bool provisional() const;
  void set_provisional(bool value);
  private:
  bool _internal_provisional() const;
  void _internal_set_provisional(bool value);
  public:

  // bool is_correction = 7;
  void clear_is_correction();
  bool is_correction() const;
  void set_is_correction(bool value);
  private:
  bool _internal_is_correction() const;
  void _internal_set_is_correction(bool value);
  public:

  // uint32 trades = 18;
  void clear_trades();
  uint32_t trades() const;
  void set_trades(uint32_t value);
  private:
  uint32_t _internal_trades() const;
  void _internal_set_trades(uint32_t value);
  public:

  // int64 high_px_q32 = 11;
  void clear_high_px_q32();
  int64_t high_px_q32() const;
  void set_high_px_q32(int64_t value);
  private:
  int64_t _internal_high_px_q32() const;
  void _internal_set_high_px_q32(int64_t value);
  public:

  // int64 low_px_q32 = 12;
  void clear_low_px_q32();
  int64_t low_px_q32() const;
  void set_low_px_q32(int64_t value);
  private:
  int64_t _internal_low_px_q32() const;
  void _internal_set_low_px_q32(int64_t value);
  public:

  // int64 close_px_q32 = 13;
  void clear_close_px_q32();
  int64_t close_px_q32() const;
  void set_close_px_q32(int64_t value);
  private:
  int64_t _internal_close_px_q32() const;
  void _internal_set_close_px_q32(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.Candle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pair_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pool_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeframe_;
    ::dex::sol::v1::U128* vwap_num_;
    ::dex::sol::v1::U128* vwap_den_;
    ::dex::sol::v1::U128* vol_base_;
    ::dex::sol::v1::U128* vol_quote_;
    uint64_t chain_id_;
    uint64_t window_start_;
    int64_t open_px_q32_;
    bool provisional_;
    bool is_correction_;
    uint32_t trades_;
    int64_t high_px_q32_;
    int64_t low_px_q32_;
    int64_t close_px_q32_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class WalletHeuristics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dex.sol.v1.WalletHeuristics) */ {
 public:
  inline WalletHeuristics() : WalletHeuristics(nullptr) {}
  ~WalletHeuristics() override;
  explicit PROTOBUF_CONSTEXPR WalletHeuristics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalletHeuristics(const WalletHeuristics& from);
  WalletHeuristics(WalletHeuristics&& from) noexcept
    : WalletHeuristics() {
    *this = ::std::move(from);
  }

  inline WalletHeuristics& operator=(const WalletHeuristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletHeuristics& operator=(WalletHeuristics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalletHeuristics& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalletHeuristics* internal_default_instance() {
    return reinterpret_cast<const WalletHeuristics*>(
               &_WalletHeuristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WalletHeuristics& a, WalletHeuristics& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletHeuristics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletHeuristics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalletHeuristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalletHeuristics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalletHeuristics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalletHeuristics& from) {
    WalletHeuristics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletHeuristics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dex.sol.v1.WalletHeuristics";
  }
  protected:
  explicit WalletHeuristics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletFieldNumber = 2,
    kChainIdFieldNumber = 1,
    kFirstSeenSlotFieldNumber = 3,
    kSwaps24HFieldNumber = 4,
    kSwaps7DFieldNumber = 5,
    kIsFreshFieldNumber = 6,
    kIsSniperFieldNumber = 7,
    kBundledPctFieldNumber = 8,
  };
  // string wallet = 2;
  void clear_wallet();
  const std::string& wallet() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wallet(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wallet();
  PROTOBUF_NODISCARD std::string* release_wallet();
  void set_allocated_wallet(std::string* wallet);
  private:
  const std::string& _internal_wallet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet(const std::string& value);
  std::string* _internal_mutable_wallet();
  public:

  // uint64 chain_id = 1;
  void clear_chain_id();
  uint64_t chain_id() const;
  void set_chain_id(uint64_t value);
  private:
  uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(uint64_t value);
  public:

  // uint64 first_seen_slot = 3;
  void clear_first_seen_slot();
  uint64_t first_seen_slot() const;
  void set_first_seen_slot(uint64_t value);
  private:
  uint64_t _internal_first_seen_slot() const;
  void _internal_set_first_seen_slot(uint64_t value);
  public:

  // uint32 swaps_24h = 4;
  void clear_swaps_24h();
  uint32_t swaps_24h() const;
  void set_swaps_24h(uint32_t value);
  private:
  uint32_t _internal_swaps_24h() const;
  void _internal_set_swaps_24h(uint32_t value);
  public:

  // uint32 swaps_7d = 5;
  void clear_swaps_7d();
  uint32_t swaps_7d() const;
  void set_swaps_7d(uint32_t value);
  private:
  uint32_t _internal_swaps_7d() const;
  void _internal_set_swaps_7d(uint32_t value);
  public:

  // bool is_fresh = 6;
  void clear_is_fresh();
  bool is_fresh() const;
  void set_is_fresh(bool value);
  private:
  bool _internal_is_fresh() const;
  void _internal_set_is_fresh(bool value);
  public:

  // bool is_sniper = 7;
  void clear_is_sniper();
  bool is_sniper() const;
  void set_is_sniper(bool value);
  private:
  bool _internal_is_sniper() const;
  void _internal_set_is_sniper(bool value);
  public:

  // float bundled_pct = 8;
  void clear_bundled_pct();
  float bundled_pct() const;
  void set_bundled_pct(float value);
  private:
  float _internal_bundled_pct() const;
  void _internal_set_bundled_pct(float value);
  public:

  // @@protoc_insertion_point(class_scope:dex.sol.v1.WalletHeuristics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wallet_;
    uint64_t chain_id_;
    uint64_t first_seen_slot_;
    uint32_t swaps_24h_;
    uint32_t swaps_7d_;
    bool is_fresh_;
    bool is_sniper_;
    float bundled_pct_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dex_2fsol_2fv1_2fcore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// U128

// uint64 hi = 1;
inline void U128::clear_hi() {
  _impl_.hi_ = uint64_t{0u};
}
inline uint64_t U128::_internal_hi() const {
  return _impl_.hi_;
}
inline uint64_t U128::hi() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.U128.hi)
  return _internal_hi();
}
inline void U128::_internal_set_hi(uint64_t value) {
  
  _impl_.hi_ = value;
}
inline void U128::set_hi(uint64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.U128.hi)
}

// uint64 lo = 2;
inline void U128::clear_lo() {
  _impl_.lo_ = uint64_t{0u};
}
inline uint64_t U128::_internal_lo() const {
  return _impl_.lo_;
}
inline uint64_t U128::lo() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.U128.lo)
  return _internal_lo();
}
inline void U128::_internal_set_lo(uint64_t value) {
  
  _impl_.lo_ = value;
}
inline void U128::set_lo(uint64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.U128.lo)
}

// -------------------------------------------------------------------

// BlockHead

// uint64 chain_id = 1;
inline void BlockHead::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t BlockHead::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t BlockHead::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.BlockHead.chain_id)
  return _internal_chain_id();
}
inline void BlockHead::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void BlockHead::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.BlockHead.chain_id)
}

// uint64 slot = 2;
inline void BlockHead::clear_slot() {
  _impl_.slot_ = uint64_t{0u};
}
inline uint64_t BlockHead::_internal_slot() const {
  return _impl_.slot_;
}
inline uint64_t BlockHead::slot() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.BlockHead.slot)
  return _internal_slot();
}
inline void BlockHead::_internal_set_slot(uint64_t value) {
  
  _impl_.slot_ = value;
}
inline void BlockHead::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.BlockHead.slot)
}

// uint64 ts_sec = 3;
inline void BlockHead::clear_ts_sec() {
  _impl_.ts_sec_ = uint64_t{0u};
}
inline uint64_t BlockHead::_internal_ts_sec() const {
  return _impl_.ts_sec_;
}
inline uint64_t BlockHead::ts_sec() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.BlockHead.ts_sec)
  return _internal_ts_sec();
}
inline void BlockHead::_internal_set_ts_sec(uint64_t value) {
  
  _impl_.ts_sec_ = value;
}
inline void BlockHead::set_ts_sec(uint64_t value) {
  _internal_set_ts_sec(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.BlockHead.ts_sec)
}

// string status = 4;
inline void BlockHead::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& BlockHead::status() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.BlockHead.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHead::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.BlockHead.status)
}
inline std::string* BlockHead::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.BlockHead.status)
  return _s;
}
inline const std::string& BlockHead::_internal_status() const {
  return _impl_.status_.Get();
}
inline void BlockHead::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockHead::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockHead::release_status() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.BlockHead.status)
  return _impl_.status_.Release();
}
inline void BlockHead::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.BlockHead.status)
}

// -------------------------------------------------------------------

// TxMeta

// uint64 chain_id = 1;
inline void TxMeta::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t TxMeta::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t TxMeta::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.chain_id)
  return _internal_chain_id();
}
inline void TxMeta::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void TxMeta::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.chain_id)
}

// uint64 slot = 2;
inline void TxMeta::clear_slot() {
  _impl_.slot_ = uint64_t{0u};
}
inline uint64_t TxMeta::_internal_slot() const {
  return _impl_.slot_;
}
inline uint64_t TxMeta::slot() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.slot)
  return _internal_slot();
}
inline void TxMeta::_internal_set_slot(uint64_t value) {
  
  _impl_.slot_ = value;
}
inline void TxMeta::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.slot)
}

// string sig = 3;
inline void TxMeta::clear_sig() {
  _impl_.sig_.ClearToEmpty();
}
inline const std::string& TxMeta::sig() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.sig)
  return _internal_sig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMeta::set_sig(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sig_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.sig)
}
inline std::string* TxMeta::mutable_sig() {
  std::string* _s = _internal_mutable_sig();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.TxMeta.sig)
  return _s;
}
inline const std::string& TxMeta::_internal_sig() const {
  return _impl_.sig_.Get();
}
inline void TxMeta::_internal_set_sig(const std::string& value) {
  
  _impl_.sig_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMeta::_internal_mutable_sig() {
  
  return _impl_.sig_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMeta::release_sig() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.TxMeta.sig)
  return _impl_.sig_.Release();
}
inline void TxMeta::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    
  } else {
    
  }
  _impl_.sig_.SetAllocated(sig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sig_.IsDefault()) {
    _impl_.sig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.TxMeta.sig)
}

// bool success = 4;
inline void TxMeta::clear_success() {
  _impl_.success_ = false;
}
inline bool TxMeta::_internal_success() const {
  return _impl_.success_;
}
inline bool TxMeta::success() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.success)
  return _internal_success();
}
inline void TxMeta::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void TxMeta::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.success)
}

// uint64 cu_used = 5;
inline void TxMeta::clear_cu_used() {
  _impl_.cu_used_ = uint64_t{0u};
}
inline uint64_t TxMeta::_internal_cu_used() const {
  return _impl_.cu_used_;
}
inline uint64_t TxMeta::cu_used() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.cu_used)
  return _internal_cu_used();
}
inline void TxMeta::_internal_set_cu_used(uint64_t value) {
  
  _impl_.cu_used_ = value;
}
inline void TxMeta::set_cu_used(uint64_t value) {
  _internal_set_cu_used(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.cu_used)
}

// uint64 cu_price = 6;
inline void TxMeta::clear_cu_price() {
  _impl_.cu_price_ = uint64_t{0u};
}
inline uint64_t TxMeta::_internal_cu_price() const {
  return _impl_.cu_price_;
}
inline uint64_t TxMeta::cu_price() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.cu_price)
  return _internal_cu_price();
}
inline void TxMeta::_internal_set_cu_price(uint64_t value) {
  
  _impl_.cu_price_ = value;
}
inline void TxMeta::set_cu_price(uint64_t value) {
  _internal_set_cu_price(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.cu_price)
}

// repeated string log_msgs = 7;
inline int TxMeta::_internal_log_msgs_size() const {
  return _impl_.log_msgs_.size();
}
inline int TxMeta::log_msgs_size() const {
  return _internal_log_msgs_size();
}
inline void TxMeta::clear_log_msgs() {
  _impl_.log_msgs_.Clear();
}
inline std::string* TxMeta::add_log_msgs() {
  std::string* _s = _internal_add_log_msgs();
  // @@protoc_insertion_point(field_add_mutable:dex.sol.v1.TxMeta.log_msgs)
  return _s;
}
inline const std::string& TxMeta::_internal_log_msgs(int index) const {
  return _impl_.log_msgs_.Get(index);
}
inline const std::string& TxMeta::log_msgs(int index) const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.TxMeta.log_msgs)
  return _internal_log_msgs(index);
}
inline std::string* TxMeta::mutable_log_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.TxMeta.log_msgs)
  return _impl_.log_msgs_.Mutable(index);
}
inline void TxMeta::set_log_msgs(int index, const std::string& value) {
  _impl_.log_msgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::set_log_msgs(int index, std::string&& value) {
  _impl_.log_msgs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::set_log_msgs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.log_msgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::set_log_msgs(int index, const char* value, size_t size) {
  _impl_.log_msgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dex.sol.v1.TxMeta.log_msgs)
}
inline std::string* TxMeta::_internal_add_log_msgs() {
  return _impl_.log_msgs_.Add();
}
inline void TxMeta::add_log_msgs(const std::string& value) {
  _impl_.log_msgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::add_log_msgs(std::string&& value) {
  _impl_.log_msgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::add_log_msgs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.log_msgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dex.sol.v1.TxMeta.log_msgs)
}
inline void TxMeta::add_log_msgs(const char* value, size_t size) {
  _impl_.log_msgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dex.sol.v1.TxMeta.log_msgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxMeta::log_msgs() const {
  // @@protoc_insertion_point(field_list:dex.sol.v1.TxMeta.log_msgs)
  return _impl_.log_msgs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxMeta::mutable_log_msgs() {
  // @@protoc_insertion_point(field_mutable_list:dex.sol.v1.TxMeta.log_msgs)
  return &_impl_.log_msgs_;
}

// -------------------------------------------------------------------

// SwapEvent

// uint64 chain_id = 1;
inline void SwapEvent::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t SwapEvent::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.chain_id)
  return _internal_chain_id();
}
inline void SwapEvent::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void SwapEvent::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.chain_id)
}

// uint64 slot = 2;
inline void SwapEvent::clear_slot() {
  _impl_.slot_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_slot() const {
  return _impl_.slot_;
}
inline uint64_t SwapEvent::slot() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.slot)
  return _internal_slot();
}
inline void SwapEvent::_internal_set_slot(uint64_t value) {
  
  _impl_.slot_ = value;
}
inline void SwapEvent::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.slot)
}

// string sig = 3;
inline void SwapEvent::clear_sig() {
  _impl_.sig_.ClearToEmpty();
}
inline const std::string& SwapEvent::sig() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.sig)
  return _internal_sig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwapEvent::set_sig(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sig_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.sig)
}
inline std::string* SwapEvent::mutable_sig() {
  std::string* _s = _internal_mutable_sig();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.SwapEvent.sig)
  return _s;
}
inline const std::string& SwapEvent::_internal_sig() const {
  return _impl_.sig_.Get();
}
inline void SwapEvent::_internal_set_sig(const std::string& value) {
  
  _impl_.sig_.Set(value, GetArenaForAllocation());
}
inline std::string* SwapEvent::_internal_mutable_sig() {
  
  return _impl_.sig_.Mutable(GetArenaForAllocation());
}
inline std::string* SwapEvent::release_sig() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.SwapEvent.sig)
  return _impl_.sig_.Release();
}
inline void SwapEvent::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    
  } else {
    
  }
  _impl_.sig_.SetAllocated(sig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sig_.IsDefault()) {
    _impl_.sig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.SwapEvent.sig)
}

// uint32 index = 4;
inline void SwapEvent::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t SwapEvent::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t SwapEvent::index() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.index)
  return _internal_index();
}
inline void SwapEvent::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void SwapEvent::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.index)
}

// string program_id = 5;
inline void SwapEvent::clear_program_id() {
  _impl_.program_id_.ClearToEmpty();
}
inline const std::string& SwapEvent::program_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.program_id)
  return _internal_program_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwapEvent::set_program_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.program_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.program_id)
}
inline std::string* SwapEvent::mutable_program_id() {
  std::string* _s = _internal_mutable_program_id();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.SwapEvent.program_id)
  return _s;
}
inline const std::string& SwapEvent::_internal_program_id() const {
  return _impl_.program_id_.Get();
}
inline void SwapEvent::_internal_set_program_id(const std::string& value) {
  
  _impl_.program_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SwapEvent::_internal_mutable_program_id() {
  
  return _impl_.program_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SwapEvent::release_program_id() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.SwapEvent.program_id)
  return _impl_.program_id_.Release();
}
inline void SwapEvent::set_allocated_program_id(std::string* program_id) {
  if (program_id != nullptr) {
    
  } else {
    
  }
  _impl_.program_id_.SetAllocated(program_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.program_id_.IsDefault()) {
    _impl_.program_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.SwapEvent.program_id)
}

// string pool_id = 6;
inline void SwapEvent::clear_pool_id() {
  _impl_.pool_id_.ClearToEmpty();
}
inline const std::string& SwapEvent::pool_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.pool_id)
  return _internal_pool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwapEvent::set_pool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.pool_id)
}
inline std::string* SwapEvent::mutable_pool_id() {
  std::string* _s = _internal_mutable_pool_id();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.SwapEvent.pool_id)
  return _s;
}
inline const std::string& SwapEvent::_internal_pool_id() const {
  return _impl_.pool_id_.Get();
}
inline void SwapEvent::_internal_set_pool_id(const std::string& value) {
  
  _impl_.pool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SwapEvent::_internal_mutable_pool_id() {
  
  return _impl_.pool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SwapEvent::release_pool_id() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.SwapEvent.pool_id)
  return _impl_.pool_id_.Release();
}
inline void SwapEvent::set_allocated_pool_id(std::string* pool_id) {
  if (pool_id != nullptr) {
    
  } else {
    
  }
  _impl_.pool_id_.SetAllocated(pool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pool_id_.IsDefault()) {
    _impl_.pool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.SwapEvent.pool_id)
}

// string mint_base = 7;
inline void SwapEvent::clear_mint_base() {
  _impl_.mint_base_.ClearToEmpty();
}
inline const std::string& SwapEvent::mint_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.mint_base)
  return _internal_mint_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwapEvent::set_mint_base(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mint_base_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.mint_base)
}
inline std::string* SwapEvent::mutable_mint_base() {
  std::string* _s = _internal_mutable_mint_base();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.SwapEvent.mint_base)
  return _s;
}
inline const std::string& SwapEvent::_internal_mint_base() const {
  return _impl_.mint_base_.Get();
}
inline void SwapEvent::_internal_set_mint_base(const std::string& value) {
  
  _impl_.mint_base_.Set(value, GetArenaForAllocation());
}
inline std::string* SwapEvent::_internal_mutable_mint_base() {
  
  return _impl_.mint_base_.Mutable(GetArenaForAllocation());
}
inline std::string* SwapEvent::release_mint_base() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.SwapEvent.mint_base)
  return _impl_.mint_base_.Release();
}
inline void SwapEvent::set_allocated_mint_base(std::string* mint_base) {
  if (mint_base != nullptr) {
    
  } else {
    
  }
  _impl_.mint_base_.SetAllocated(mint_base, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mint_base_.IsDefault()) {
    _impl_.mint_base_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.SwapEvent.mint_base)
}

// string mint_quote = 8;
inline void SwapEvent::clear_mint_quote() {
  _impl_.mint_quote_.ClearToEmpty();
}
inline const std::string& SwapEvent::mint_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.mint_quote)
  return _internal_mint_quote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SwapEvent::set_mint_quote(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mint_quote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.mint_quote)
}
inline std::string* SwapEvent::mutable_mint_quote() {
  std::string* _s = _internal_mutable_mint_quote();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.SwapEvent.mint_quote)
  return _s;
}
inline const std::string& SwapEvent::_internal_mint_quote() const {
  return _impl_.mint_quote_.Get();
}
inline void SwapEvent::_internal_set_mint_quote(const std::string& value) {
  
  _impl_.mint_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* SwapEvent::_internal_mutable_mint_quote() {
  
  return _impl_.mint_quote_.Mutable(GetArenaForAllocation());
}
inline std::string* SwapEvent::release_mint_quote() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.SwapEvent.mint_quote)
  return _impl_.mint_quote_.Release();
}
inline void SwapEvent::set_allocated_mint_quote(std::string* mint_quote) {
  if (mint_quote != nullptr) {
    
  } else {
    
  }
  _impl_.mint_quote_.SetAllocated(mint_quote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mint_quote_.IsDefault()) {
    _impl_.mint_quote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.SwapEvent.mint_quote)
}

// uint32 dec_base = 9;
inline void SwapEvent::clear_dec_base() {
  _impl_.dec_base_ = 0u;
}
inline uint32_t SwapEvent::_internal_dec_base() const {
  return _impl_.dec_base_;
}
inline uint32_t SwapEvent::dec_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.dec_base)
  return _internal_dec_base();
}
inline void SwapEvent::_internal_set_dec_base(uint32_t value) {
  
  _impl_.dec_base_ = value;
}
inline void SwapEvent::set_dec_base(uint32_t value) {
  _internal_set_dec_base(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.dec_base)
}

// uint32 dec_quote = 10;
inline void SwapEvent::clear_dec_quote() {
  _impl_.dec_quote_ = 0u;
}
inline uint32_t SwapEvent::_internal_dec_quote() const {
  return _impl_.dec_quote_;
}
inline uint32_t SwapEvent::dec_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.dec_quote)
  return _internal_dec_quote();
}
inline void SwapEvent::_internal_set_dec_quote(uint32_t value) {
  
  _impl_.dec_quote_ = value;
}
inline void SwapEvent::set_dec_quote(uint32_t value) {
  _internal_set_dec_quote(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.dec_quote)
}

// uint64 base_in = 11;
inline void SwapEvent::clear_base_in() {
  _impl_.base_in_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_base_in() const {
  return _impl_.base_in_;
}
inline uint64_t SwapEvent::base_in() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.base_in)
  return _internal_base_in();
}
inline void SwapEvent::_internal_set_base_in(uint64_t value) {
  
  _impl_.base_in_ = value;
}
inline void SwapEvent::set_base_in(uint64_t value) {
  _internal_set_base_in(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.base_in)
}

// uint64 base_out = 12;
inline void SwapEvent::clear_base_out() {
  _impl_.base_out_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_base_out() const {
  return _impl_.base_out_;
}
inline uint64_t SwapEvent::base_out() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.base_out)
  return _internal_base_out();
}
inline void SwapEvent::_internal_set_base_out(uint64_t value) {
  
  _impl_.base_out_ = value;
}
inline void SwapEvent::set_base_out(uint64_t value) {
  _internal_set_base_out(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.base_out)
}

// uint64 quote_in = 13;
inline void SwapEvent::clear_quote_in() {
  _impl_.quote_in_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_quote_in() const {
  return _impl_.quote_in_;
}
inline uint64_t SwapEvent::quote_in() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.quote_in)
  return _internal_quote_in();
}
inline void SwapEvent::_internal_set_quote_in(uint64_t value) {
  
  _impl_.quote_in_ = value;
}
inline void SwapEvent::set_quote_in(uint64_t value) {
  _internal_set_quote_in(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.quote_in)
}

// uint64 quote_out = 14;
inline void SwapEvent::clear_quote_out() {
  _impl_.quote_out_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_quote_out() const {
  return _impl_.quote_out_;
}
inline uint64_t SwapEvent::quote_out() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.quote_out)
  return _internal_quote_out();
}
inline void SwapEvent::_internal_set_quote_out(uint64_t value) {
  
  _impl_.quote_out_ = value;
}
inline void SwapEvent::set_quote_out(uint64_t value) {
  _internal_set_quote_out(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.quote_out)
}

// uint64 sqrt_price_q64_pre = 15;
inline void SwapEvent::clear_sqrt_price_q64_pre() {
  _impl_.sqrt_price_q64_pre_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_sqrt_price_q64_pre() const {
  return _impl_.sqrt_price_q64_pre_;
}
inline uint64_t SwapEvent::sqrt_price_q64_pre() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.sqrt_price_q64_pre)
  return _internal_sqrt_price_q64_pre();
}
inline void SwapEvent::_internal_set_sqrt_price_q64_pre(uint64_t value) {
  
  _impl_.sqrt_price_q64_pre_ = value;
}
inline void SwapEvent::set_sqrt_price_q64_pre(uint64_t value) {
  _internal_set_sqrt_price_q64_pre(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.sqrt_price_q64_pre)
}

// uint64 sqrt_price_q64_post = 16;
inline void SwapEvent::clear_sqrt_price_q64_post() {
  _impl_.sqrt_price_q64_post_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_sqrt_price_q64_post() const {
  return _impl_.sqrt_price_q64_post_;
}
inline uint64_t SwapEvent::sqrt_price_q64_post() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.sqrt_price_q64_post)
  return _internal_sqrt_price_q64_post();
}
inline void SwapEvent::_internal_set_sqrt_price_q64_post(uint64_t value) {
  
  _impl_.sqrt_price_q64_post_ = value;
}
inline void SwapEvent::set_sqrt_price_q64_post(uint64_t value) {
  _internal_set_sqrt_price_q64_post(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.sqrt_price_q64_post)
}

// uint64 reserves_base = 17;
inline void SwapEvent::clear_reserves_base() {
  _impl_.reserves_base_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_reserves_base() const {
  return _impl_.reserves_base_;
}
inline uint64_t SwapEvent::reserves_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.reserves_base)
  return _internal_reserves_base();
}
inline void SwapEvent::_internal_set_reserves_base(uint64_t value) {
  
  _impl_.reserves_base_ = value;
}
inline void SwapEvent::set_reserves_base(uint64_t value) {
  _internal_set_reserves_base(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.reserves_base)
}

// uint64 reserves_quote = 18;
inline void SwapEvent::clear_reserves_quote() {
  _impl_.reserves_quote_ = uint64_t{0u};
}
inline uint64_t SwapEvent::_internal_reserves_quote() const {
  return _impl_.reserves_quote_;
}
inline uint64_t SwapEvent::reserves_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.reserves_quote)
  return _internal_reserves_quote();
}
inline void SwapEvent::_internal_set_reserves_quote(uint64_t value) {
  
  _impl_.reserves_quote_ = value;
}
inline void SwapEvent::set_reserves_quote(uint64_t value) {
  _internal_set_reserves_quote(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.reserves_quote)
}

// uint32 fee_bps = 19;
inline void SwapEvent::clear_fee_bps() {
  _impl_.fee_bps_ = 0u;
}
inline uint32_t SwapEvent::_internal_fee_bps() const {
  return _impl_.fee_bps_;
}
inline uint32_t SwapEvent::fee_bps() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.fee_bps)
  return _internal_fee_bps();
}
inline void SwapEvent::_internal_set_fee_bps(uint32_t value) {
  
  _impl_.fee_bps_ = value;
}
inline void SwapEvent::set_fee_bps(uint32_t value) {
  _internal_set_fee_bps(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.fee_bps)
}

// bool provisional = 20;
inline void SwapEvent::clear_provisional() {
  _impl_.provisional_ = false;
}
inline bool SwapEvent::_internal_provisional() const {
  return _impl_.provisional_;
}
inline bool SwapEvent::provisional() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.provisional)
  return _internal_provisional();
}
inline void SwapEvent::_internal_set_provisional(bool value) {
  
  _impl_.provisional_ = value;
}
inline void SwapEvent::set_provisional(bool value) {
  _internal_set_provisional(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.provisional)
}

// bool is_undo = 21;
inline void SwapEvent::clear_is_undo() {
  _impl_.is_undo_ = false;
}
inline bool SwapEvent::_internal_is_undo() const {
  return _impl_.is_undo_;
}
inline bool SwapEvent::is_undo() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.SwapEvent.is_undo)
  return _internal_is_undo();
}
inline void SwapEvent::_internal_set_is_undo(bool value) {
  
  _impl_.is_undo_ = value;
}
inline void SwapEvent::set_is_undo(bool value) {
  _internal_set_is_undo(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.SwapEvent.is_undo)
}

// -------------------------------------------------------------------

// PoolSnapshot

// uint64 chain_id = 1;
inline void PoolSnapshot::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t PoolSnapshot::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.chain_id)
  return _internal_chain_id();
}
inline void PoolSnapshot::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void PoolSnapshot::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.chain_id)
}

// uint64 slot = 2;
inline void PoolSnapshot::clear_slot() {
  _impl_.slot_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_slot() const {
  return _impl_.slot_;
}
inline uint64_t PoolSnapshot::slot() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.slot)
  return _internal_slot();
}
inline void PoolSnapshot::_internal_set_slot(uint64_t value) {
  
  _impl_.slot_ = value;
}
inline void PoolSnapshot::set_slot(uint64_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.slot)
}

// string pool_id = 3;
inline void PoolSnapshot::clear_pool_id() {
  _impl_.pool_id_.ClearToEmpty();
}
inline const std::string& PoolSnapshot::pool_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.pool_id)
  return _internal_pool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PoolSnapshot::set_pool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.pool_id)
}
inline std::string* PoolSnapshot::mutable_pool_id() {
  std::string* _s = _internal_mutable_pool_id();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.PoolSnapshot.pool_id)
  return _s;
}
inline const std::string& PoolSnapshot::_internal_pool_id() const {
  return _impl_.pool_id_.Get();
}
inline void PoolSnapshot::_internal_set_pool_id(const std::string& value) {
  
  _impl_.pool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PoolSnapshot::_internal_mutable_pool_id() {
  
  return _impl_.pool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PoolSnapshot::release_pool_id() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.PoolSnapshot.pool_id)
  return _impl_.pool_id_.Release();
}
inline void PoolSnapshot::set_allocated_pool_id(std::string* pool_id) {
  if (pool_id != nullptr) {
    
  } else {
    
  }
  _impl_.pool_id_.SetAllocated(pool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pool_id_.IsDefault()) {
    _impl_.pool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.PoolSnapshot.pool_id)
}

// string mint_base = 4;
inline void PoolSnapshot::clear_mint_base() {
  _impl_.mint_base_.ClearToEmpty();
}
inline const std::string& PoolSnapshot::mint_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.mint_base)
  return _internal_mint_base();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PoolSnapshot::set_mint_base(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mint_base_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.mint_base)
}
inline std::string* PoolSnapshot::mutable_mint_base() {
  std::string* _s = _internal_mutable_mint_base();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.PoolSnapshot.mint_base)
  return _s;
}
inline const std::string& PoolSnapshot::_internal_mint_base() const {
  return _impl_.mint_base_.Get();
}
inline void PoolSnapshot::_internal_set_mint_base(const std::string& value) {
  
  _impl_.mint_base_.Set(value, GetArenaForAllocation());
}
inline std::string* PoolSnapshot::_internal_mutable_mint_base() {
  
  return _impl_.mint_base_.Mutable(GetArenaForAllocation());
}
inline std::string* PoolSnapshot::release_mint_base() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.PoolSnapshot.mint_base)
  return _impl_.mint_base_.Release();
}
inline void PoolSnapshot::set_allocated_mint_base(std::string* mint_base) {
  if (mint_base != nullptr) {
    
  } else {
    
  }
  _impl_.mint_base_.SetAllocated(mint_base, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mint_base_.IsDefault()) {
    _impl_.mint_base_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.PoolSnapshot.mint_base)
}

// string mint_quote = 5;
inline void PoolSnapshot::clear_mint_quote() {
  _impl_.mint_quote_.ClearToEmpty();
}
inline const std::string& PoolSnapshot::mint_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.mint_quote)
  return _internal_mint_quote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PoolSnapshot::set_mint_quote(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mint_quote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.mint_quote)
}
inline std::string* PoolSnapshot::mutable_mint_quote() {
  std::string* _s = _internal_mutable_mint_quote();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.PoolSnapshot.mint_quote)
  return _s;
}
inline const std::string& PoolSnapshot::_internal_mint_quote() const {
  return _impl_.mint_quote_.Get();
}
inline void PoolSnapshot::_internal_set_mint_quote(const std::string& value) {
  
  _impl_.mint_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* PoolSnapshot::_internal_mutable_mint_quote() {
  
  return _impl_.mint_quote_.Mutable(GetArenaForAllocation());
}
inline std::string* PoolSnapshot::release_mint_quote() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.PoolSnapshot.mint_quote)
  return _impl_.mint_quote_.Release();
}
inline void PoolSnapshot::set_allocated_mint_quote(std::string* mint_quote) {
  if (mint_quote != nullptr) {
    
  } else {
    
  }
  _impl_.mint_quote_.SetAllocated(mint_quote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mint_quote_.IsDefault()) {
    _impl_.mint_quote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.PoolSnapshot.mint_quote)
}

// uint64 sqrt_price_q64 = 6;
inline void PoolSnapshot::clear_sqrt_price_q64() {
  _impl_.sqrt_price_q64_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_sqrt_price_q64() const {
  return _impl_.sqrt_price_q64_;
}
inline uint64_t PoolSnapshot::sqrt_price_q64() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.sqrt_price_q64)
  return _internal_sqrt_price_q64();
}
inline void PoolSnapshot::_internal_set_sqrt_price_q64(uint64_t value) {
  
  _impl_.sqrt_price_q64_ = value;
}
inline void PoolSnapshot::set_sqrt_price_q64(uint64_t value) {
  _internal_set_sqrt_price_q64(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.sqrt_price_q64)
}

// uint64 reserves_base = 7;
inline void PoolSnapshot::clear_reserves_base() {
  _impl_.reserves_base_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_reserves_base() const {
  return _impl_.reserves_base_;
}
inline uint64_t PoolSnapshot::reserves_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.reserves_base)
  return _internal_reserves_base();
}
inline void PoolSnapshot::_internal_set_reserves_base(uint64_t value) {
  
  _impl_.reserves_base_ = value;
}
inline void PoolSnapshot::set_reserves_base(uint64_t value) {
  _internal_set_reserves_base(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.reserves_base)
}

// uint64 reserves_quote = 8;
inline void PoolSnapshot::clear_reserves_quote() {
  _impl_.reserves_quote_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_reserves_quote() const {
  return _impl_.reserves_quote_;
}
inline uint64_t PoolSnapshot::reserves_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.reserves_quote)
  return _internal_reserves_quote();
}
inline void PoolSnapshot::_internal_set_reserves_quote(uint64_t value) {
  
  _impl_.reserves_quote_ = value;
}
inline void PoolSnapshot::set_reserves_quote(uint64_t value) {
  _internal_set_reserves_quote(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.reserves_quote)
}

// uint32 fee_bps = 9;
inline void PoolSnapshot::clear_fee_bps() {
  _impl_.fee_bps_ = 0u;
}
inline uint32_t PoolSnapshot::_internal_fee_bps() const {
  return _impl_.fee_bps_;
}
inline uint32_t PoolSnapshot::fee_bps() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.fee_bps)
  return _internal_fee_bps();
}
inline void PoolSnapshot::_internal_set_fee_bps(uint32_t value) {
  
  _impl_.fee_bps_ = value;
}
inline void PoolSnapshot::set_fee_bps(uint32_t value) {
  _internal_set_fee_bps(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.fee_bps)
}

// uint64 liquidity = 10;
inline void PoolSnapshot::clear_liquidity() {
  _impl_.liquidity_ = uint64_t{0u};
}
inline uint64_t PoolSnapshot::_internal_liquidity() const {
  return _impl_.liquidity_;
}
inline uint64_t PoolSnapshot::liquidity() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.PoolSnapshot.liquidity)
  return _internal_liquidity();
}
inline void PoolSnapshot::_internal_set_liquidity(uint64_t value) {
  
  _impl_.liquidity_ = value;
}
inline void PoolSnapshot::set_liquidity(uint64_t value) {
  _internal_set_liquidity(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.PoolSnapshot.liquidity)
}

// -------------------------------------------------------------------

// Candle

// uint64 chain_id = 1;
inline void Candle::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t Candle::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t Candle::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.chain_id)
  return _internal_chain_id();
}
inline void Candle::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void Candle::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.chain_id)
}

// string pair_id = 2;
inline void Candle::clear_pair_id() {
  _impl_.pair_id_.ClearToEmpty();
}
inline const std::string& Candle::pair_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.pair_id)
  return _internal_pair_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candle::set_pair_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pair_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.pair_id)
}
inline std::string* Candle::mutable_pair_id() {
  std::string* _s = _internal_mutable_pair_id();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.pair_id)
  return _s;
}
inline const std::string& Candle::_internal_pair_id() const {
  return _impl_.pair_id_.Get();
}
inline void Candle::_internal_set_pair_id(const std::string& value) {
  
  _impl_.pair_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Candle::_internal_mutable_pair_id() {
  
  return _impl_.pair_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Candle::release_pair_id() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.pair_id)
  return _impl_.pair_id_.Release();
}
inline void Candle::set_allocated_pair_id(std::string* pair_id) {
  if (pair_id != nullptr) {
    
  } else {
    
  }
  _impl_.pair_id_.SetAllocated(pair_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pair_id_.IsDefault()) {
    _impl_.pair_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.pair_id)
}

// string pool_id = 3;
inline void Candle::clear_pool_id() {
  _impl_.pool_id_.ClearToEmpty();
}
inline const std::string& Candle::pool_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.pool_id)
  return _internal_pool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candle::set_pool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.pool_id)
}
inline std::string* Candle::mutable_pool_id() {
  std::string* _s = _internal_mutable_pool_id();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.pool_id)
  return _s;
}
inline const std::string& Candle::_internal_pool_id() const {
  return _impl_.pool_id_.Get();
}
inline void Candle::_internal_set_pool_id(const std::string& value) {
  
  _impl_.pool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Candle::_internal_mutable_pool_id() {
  
  return _impl_.pool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Candle::release_pool_id() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.pool_id)
  return _impl_.pool_id_.Release();
}
inline void Candle::set_allocated_pool_id(std::string* pool_id) {
  if (pool_id != nullptr) {
    
  } else {
    
  }
  _impl_.pool_id_.SetAllocated(pool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pool_id_.IsDefault()) {
    _impl_.pool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.pool_id)
}

// string timeframe = 4;
inline void Candle::clear_timeframe() {
  _impl_.timeframe_.ClearToEmpty();
}
inline const std::string& Candle::timeframe() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.timeframe)
  return _internal_timeframe();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candle::set_timeframe(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timeframe_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.timeframe)
}
inline std::string* Candle::mutable_timeframe() {
  std::string* _s = _internal_mutable_timeframe();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.timeframe)
  return _s;
}
inline const std::string& Candle::_internal_timeframe() const {
  return _impl_.timeframe_.Get();
}
inline void Candle::_internal_set_timeframe(const std::string& value) {
  
  _impl_.timeframe_.Set(value, GetArenaForAllocation());
}
inline std::string* Candle::_internal_mutable_timeframe() {
  
  return _impl_.timeframe_.Mutable(GetArenaForAllocation());
}
inline std::string* Candle::release_timeframe() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.timeframe)
  return _impl_.timeframe_.Release();
}
inline void Candle::set_allocated_timeframe(std::string* timeframe) {
  if (timeframe != nullptr) {
    
  } else {
    
  }
  _impl_.timeframe_.SetAllocated(timeframe, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timeframe_.IsDefault()) {
    _impl_.timeframe_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.timeframe)
}

// uint64 window_start = 5;
inline void Candle::clear_window_start() {
  _impl_.window_start_ = uint64_t{0u};
}
inline uint64_t Candle::_internal_window_start() const {
  return _impl_.window_start_;
}
inline uint64_t Candle::window_start() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.window_start)
  return _internal_window_start();
}
inline void Candle::_internal_set_window_start(uint64_t value) {
  
  _impl_.window_start_ = value;
}
inline void Candle::set_window_start(uint64_t value) {
  _internal_set_window_start(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.window_start)
}

// bool provisional = 6;
inline void Candle::clear_provisional() {
  _impl_.provisional_ = false;
}
inline bool Candle::_internal_provisional() const {
  return _impl_.provisional_;
}
inline bool Candle::provisional() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.provisional)
  return _internal_provisional();
}
inline void Candle::_internal_set_provisional(bool value) {
  
  _impl_.provisional_ = value;
}
inline void Candle::set_provisional(bool value) {
  _internal_set_provisional(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.provisional)
}

// bool is_correction = 7;
inline void Candle::clear_is_correction() {
  _impl_.is_correction_ = false;
}
inline bool Candle::_internal_is_correction() const {
  return _impl_.is_correction_;
}
inline bool Candle::is_correction() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.is_correction)
  return _internal_is_correction();
}
inline void Candle::_internal_set_is_correction(bool value) {
  
  _impl_.is_correction_ = value;
}
inline void Candle::set_is_correction(bool value) {
  _internal_set_is_correction(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.is_correction)
}

// int64 open_px_q32 = 10;
inline void Candle::clear_open_px_q32() {
  _impl_.open_px_q32_ = int64_t{0};
}
inline int64_t Candle::_internal_open_px_q32() const {
  return _impl_.open_px_q32_;
}
inline int64_t Candle::open_px_q32() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.open_px_q32)
  return _internal_open_px_q32();
}
inline void Candle::_internal_set_open_px_q32(int64_t value) {
  
  _impl_.open_px_q32_ = value;
}
inline void Candle::set_open_px_q32(int64_t value) {
  _internal_set_open_px_q32(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.open_px_q32)
}

// int64 high_px_q32 = 11;
inline void Candle::clear_high_px_q32() {
  _impl_.high_px_q32_ = int64_t{0};
}
inline int64_t Candle::_internal_high_px_q32() const {
  return _impl_.high_px_q32_;
}
inline int64_t Candle::high_px_q32() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.high_px_q32)
  return _internal_high_px_q32();
}
inline void Candle::_internal_set_high_px_q32(int64_t value) {
  
  _impl_.high_px_q32_ = value;
}
inline void Candle::set_high_px_q32(int64_t value) {
  _internal_set_high_px_q32(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.high_px_q32)
}

// int64 low_px_q32 = 12;
inline void Candle::clear_low_px_q32() {
  _impl_.low_px_q32_ = int64_t{0};
}
inline int64_t Candle::_internal_low_px_q32() const {
  return _impl_.low_px_q32_;
}
inline int64_t Candle::low_px_q32() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.low_px_q32)
  return _internal_low_px_q32();
}
inline void Candle::_internal_set_low_px_q32(int64_t value) {
  
  _impl_.low_px_q32_ = value;
}
inline void Candle::set_low_px_q32(int64_t value) {
  _internal_set_low_px_q32(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.low_px_q32)
}

// int64 close_px_q32 = 13;
inline void Candle::clear_close_px_q32() {
  _impl_.close_px_q32_ = int64_t{0};
}
inline int64_t Candle::_internal_close_px_q32() const {
  return _impl_.close_px_q32_;
}
inline int64_t Candle::close_px_q32() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.close_px_q32)
  return _internal_close_px_q32();
}
inline void Candle::_internal_set_close_px_q32(int64_t value) {
  
  _impl_.close_px_q32_ = value;
}
inline void Candle::set_close_px_q32(int64_t value) {
  _internal_set_close_px_q32(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.close_px_q32)
}

// .dex.sol.v1.U128 vwap_num = 14;
inline bool Candle::_internal_has_vwap_num() const {
  return this != internal_default_instance() && _impl_.vwap_num_ != nullptr;
}
inline bool Candle::has_vwap_num() const {
  return _internal_has_vwap_num();
}
inline void Candle::clear_vwap_num() {
  if (GetArenaForAllocation() == nullptr && _impl_.vwap_num_ != nullptr) {
    delete _impl_.vwap_num_;
  }
  _impl_.vwap_num_ = nullptr;
}
inline const ::dex::sol::v1::U128& Candle::_internal_vwap_num() const {
  const ::dex::sol::v1::U128* p = _impl_.vwap_num_;
  return p != nullptr ? *p : reinterpret_cast<const ::dex::sol::v1::U128&>(
      ::dex::sol::v1::_U128_default_instance_);
}
inline const ::dex::sol::v1::U128& Candle::vwap_num() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.vwap_num)
  return _internal_vwap_num();
}
inline void Candle::unsafe_arena_set_allocated_vwap_num(
    ::dex::sol::v1::U128* vwap_num) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vwap_num_);
  }
  _impl_.vwap_num_ = vwap_num;
  if (vwap_num) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dex.sol.v1.Candle.vwap_num)
}
inline ::dex::sol::v1::U128* Candle::release_vwap_num() {
  
  ::dex::sol::v1::U128* temp = _impl_.vwap_num_;
  _impl_.vwap_num_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dex::sol::v1::U128* Candle::unsafe_arena_release_vwap_num() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.vwap_num)
  
  ::dex::sol::v1::U128* temp = _impl_.vwap_num_;
  _impl_.vwap_num_ = nullptr;
  return temp;
}
inline ::dex::sol::v1::U128* Candle::_internal_mutable_vwap_num() {
  
  if (_impl_.vwap_num_ == nullptr) {
    auto* p = CreateMaybeMessage<::dex::sol::v1::U128>(GetArenaForAllocation());
    _impl_.vwap_num_ = p;
  }
  return _impl_.vwap_num_;
}
inline ::dex::sol::v1::U128* Candle::mutable_vwap_num() {
  ::dex::sol::v1::U128* _msg = _internal_mutable_vwap_num();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.vwap_num)
  return _msg;
}
inline void Candle::set_allocated_vwap_num(::dex::sol::v1::U128* vwap_num) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vwap_num_;
  }
  if (vwap_num) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vwap_num);
    if (message_arena != submessage_arena) {
      vwap_num = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vwap_num, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vwap_num_ = vwap_num;
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.vwap_num)
}

// .dex.sol.v1.U128 vwap_den = 15;
inline bool Candle::_internal_has_vwap_den() const {
  return this != internal_default_instance() && _impl_.vwap_den_ != nullptr;
}
inline bool Candle::has_vwap_den() const {
  return _internal_has_vwap_den();
}
inline void Candle::clear_vwap_den() {
  if (GetArenaForAllocation() == nullptr && _impl_.vwap_den_ != nullptr) {
    delete _impl_.vwap_den_;
  }
  _impl_.vwap_den_ = nullptr;
}
inline const ::dex::sol::v1::U128& Candle::_internal_vwap_den() const {
  const ::dex::sol::v1::U128* p = _impl_.vwap_den_;
  return p != nullptr ? *p : reinterpret_cast<const ::dex::sol::v1::U128&>(
      ::dex::sol::v1::_U128_default_instance_);
}
inline const ::dex::sol::v1::U128& Candle::vwap_den() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.vwap_den)
  return _internal_vwap_den();
}
inline void Candle::unsafe_arena_set_allocated_vwap_den(
    ::dex::sol::v1::U128* vwap_den) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vwap_den_);
  }
  _impl_.vwap_den_ = vwap_den;
  if (vwap_den) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dex.sol.v1.Candle.vwap_den)
}
inline ::dex::sol::v1::U128* Candle::release_vwap_den() {
  
  ::dex::sol::v1::U128* temp = _impl_.vwap_den_;
  _impl_.vwap_den_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dex::sol::v1::U128* Candle::unsafe_arena_release_vwap_den() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.vwap_den)
  
  ::dex::sol::v1::U128* temp = _impl_.vwap_den_;
  _impl_.vwap_den_ = nullptr;
  return temp;
}
inline ::dex::sol::v1::U128* Candle::_internal_mutable_vwap_den() {
  
  if (_impl_.vwap_den_ == nullptr) {
    auto* p = CreateMaybeMessage<::dex::sol::v1::U128>(GetArenaForAllocation());
    _impl_.vwap_den_ = p;
  }
  return _impl_.vwap_den_;
}
inline ::dex::sol::v1::U128* Candle::mutable_vwap_den() {
  ::dex::sol::v1::U128* _msg = _internal_mutable_vwap_den();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.vwap_den)
  return _msg;
}
inline void Candle::set_allocated_vwap_den(::dex::sol::v1::U128* vwap_den) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vwap_den_;
  }
  if (vwap_den) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vwap_den);
    if (message_arena != submessage_arena) {
      vwap_den = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vwap_den, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vwap_den_ = vwap_den;
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.vwap_den)
}

// .dex.sol.v1.U128 vol_base = 16;
inline bool Candle::_internal_has_vol_base() const {
  return this != internal_default_instance() && _impl_.vol_base_ != nullptr;
}
inline bool Candle::has_vol_base() const {
  return _internal_has_vol_base();
}
inline void Candle::clear_vol_base() {
  if (GetArenaForAllocation() == nullptr && _impl_.vol_base_ != nullptr) {
    delete _impl_.vol_base_;
  }
  _impl_.vol_base_ = nullptr;
}
inline const ::dex::sol::v1::U128& Candle::_internal_vol_base() const {
  const ::dex::sol::v1::U128* p = _impl_.vol_base_;
  return p != nullptr ? *p : reinterpret_cast<const ::dex::sol::v1::U128&>(
      ::dex::sol::v1::_U128_default_instance_);
}
inline const ::dex::sol::v1::U128& Candle::vol_base() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.vol_base)
  return _internal_vol_base();
}
inline void Candle::unsafe_arena_set_allocated_vol_base(
    ::dex::sol::v1::U128* vol_base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vol_base_);
  }
  _impl_.vol_base_ = vol_base;
  if (vol_base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dex.sol.v1.Candle.vol_base)
}
inline ::dex::sol::v1::U128* Candle::release_vol_base() {
  
  ::dex::sol::v1::U128* temp = _impl_.vol_base_;
  _impl_.vol_base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dex::sol::v1::U128* Candle::unsafe_arena_release_vol_base() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.vol_base)
  
  ::dex::sol::v1::U128* temp = _impl_.vol_base_;
  _impl_.vol_base_ = nullptr;
  return temp;
}
inline ::dex::sol::v1::U128* Candle::_internal_mutable_vol_base() {
  
  if (_impl_.vol_base_ == nullptr) {
    auto* p = CreateMaybeMessage<::dex::sol::v1::U128>(GetArenaForAllocation());
    _impl_.vol_base_ = p;
  }
  return _impl_.vol_base_;
}
inline ::dex::sol::v1::U128* Candle::mutable_vol_base() {
  ::dex::sol::v1::U128* _msg = _internal_mutable_vol_base();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.vol_base)
  return _msg;
}
inline void Candle::set_allocated_vol_base(::dex::sol::v1::U128* vol_base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vol_base_;
  }
  if (vol_base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vol_base);
    if (message_arena != submessage_arena) {
      vol_base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vol_base, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vol_base_ = vol_base;
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.vol_base)
}

// .dex.sol.v1.U128 vol_quote = 17;
inline bool Candle::_internal_has_vol_quote() const {
  return this != internal_default_instance() && _impl_.vol_quote_ != nullptr;
}
inline bool Candle::has_vol_quote() const {
  return _internal_has_vol_quote();
}
inline void Candle::clear_vol_quote() {
  if (GetArenaForAllocation() == nullptr && _impl_.vol_quote_ != nullptr) {
    delete _impl_.vol_quote_;
  }
  _impl_.vol_quote_ = nullptr;
}
inline const ::dex::sol::v1::U128& Candle::_internal_vol_quote() const {
  const ::dex::sol::v1::U128* p = _impl_.vol_quote_;
  return p != nullptr ? *p : reinterpret_cast<const ::dex::sol::v1::U128&>(
      ::dex::sol::v1::_U128_default_instance_);
}
inline const ::dex::sol::v1::U128& Candle::vol_quote() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.vol_quote)
  return _internal_vol_quote();
}
inline void Candle::unsafe_arena_set_allocated_vol_quote(
    ::dex::sol::v1::U128* vol_quote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vol_quote_);
  }
  _impl_.vol_quote_ = vol_quote;
  if (vol_quote) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dex.sol.v1.Candle.vol_quote)
}
inline ::dex::sol::v1::U128* Candle::release_vol_quote() {
  
  ::dex::sol::v1::U128* temp = _impl_.vol_quote_;
  _impl_.vol_quote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dex::sol::v1::U128* Candle::unsafe_arena_release_vol_quote() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.Candle.vol_quote)
  
  ::dex::sol::v1::U128* temp = _impl_.vol_quote_;
  _impl_.vol_quote_ = nullptr;
  return temp;
}
inline ::dex::sol::v1::U128* Candle::_internal_mutable_vol_quote() {
  
  if (_impl_.vol_quote_ == nullptr) {
    auto* p = CreateMaybeMessage<::dex::sol::v1::U128>(GetArenaForAllocation());
    _impl_.vol_quote_ = p;
  }
  return _impl_.vol_quote_;
}
inline ::dex::sol::v1::U128* Candle::mutable_vol_quote() {
  ::dex::sol::v1::U128* _msg = _internal_mutable_vol_quote();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.Candle.vol_quote)
  return _msg;
}
inline void Candle::set_allocated_vol_quote(::dex::sol::v1::U128* vol_quote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vol_quote_;
  }
  if (vol_quote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vol_quote);
    if (message_arena != submessage_arena) {
      vol_quote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vol_quote, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vol_quote_ = vol_quote;
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.Candle.vol_quote)
}

// uint32 trades = 18;
inline void Candle::clear_trades() {
  _impl_.trades_ = 0u;
}
inline uint32_t Candle::_internal_trades() const {
  return _impl_.trades_;
}
inline uint32_t Candle::trades() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.Candle.trades)
  return _internal_trades();
}
inline void Candle::_internal_set_trades(uint32_t value) {
  
  _impl_.trades_ = value;
}
inline void Candle::set_trades(uint32_t value) {
  _internal_set_trades(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.Candle.trades)
}

// -------------------------------------------------------------------

// WalletHeuristics

// uint64 chain_id = 1;
inline void WalletHeuristics::clear_chain_id() {
  _impl_.chain_id_ = uint64_t{0u};
}
inline uint64_t WalletHeuristics::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline uint64_t WalletHeuristics::chain_id() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.chain_id)
  return _internal_chain_id();
}
inline void WalletHeuristics::_internal_set_chain_id(uint64_t value) {
  
  _impl_.chain_id_ = value;
}
inline void WalletHeuristics::set_chain_id(uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.chain_id)
}

// string wallet = 2;
inline void WalletHeuristics::clear_wallet() {
  _impl_.wallet_.ClearToEmpty();
}
inline const std::string& WalletHeuristics::wallet() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.wallet)
  return _internal_wallet();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletHeuristics::set_wallet(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wallet_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.wallet)
}
inline std::string* WalletHeuristics::mutable_wallet() {
  std::string* _s = _internal_mutable_wallet();
  // @@protoc_insertion_point(field_mutable:dex.sol.v1.WalletHeuristics.wallet)
  return _s;
}
inline const std::string& WalletHeuristics::_internal_wallet() const {
  return _impl_.wallet_.Get();
}
inline void WalletHeuristics::_internal_set_wallet(const std::string& value) {
  
  _impl_.wallet_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletHeuristics::_internal_mutable_wallet() {
  
  return _impl_.wallet_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletHeuristics::release_wallet() {
  // @@protoc_insertion_point(field_release:dex.sol.v1.WalletHeuristics.wallet)
  return _impl_.wallet_.Release();
}
inline void WalletHeuristics::set_allocated_wallet(std::string* wallet) {
  if (wallet != nullptr) {
    
  } else {
    
  }
  _impl_.wallet_.SetAllocated(wallet, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wallet_.IsDefault()) {
    _impl_.wallet_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dex.sol.v1.WalletHeuristics.wallet)
}

// uint64 first_seen_slot = 3;
inline void WalletHeuristics::clear_first_seen_slot() {
  _impl_.first_seen_slot_ = uint64_t{0u};
}
inline uint64_t WalletHeuristics::_internal_first_seen_slot() const {
  return _impl_.first_seen_slot_;
}
inline uint64_t WalletHeuristics::first_seen_slot() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.first_seen_slot)
  return _internal_first_seen_slot();
}
inline void WalletHeuristics::_internal_set_first_seen_slot(uint64_t value) {
  
  _impl_.first_seen_slot_ = value;
}
inline void WalletHeuristics::set_first_seen_slot(uint64_t value) {
  _internal_set_first_seen_slot(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.first_seen_slot)
}

// uint32 swaps_24h = 4;
inline void WalletHeuristics::clear_swaps_24h() {
  _impl_.swaps_24h_ = 0u;
}
inline uint32_t WalletHeuristics::_internal_swaps_24h() const {
  return _impl_.swaps_24h_;
}
inline uint32_t WalletHeuristics::swaps_24h() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.swaps_24h)
  return _internal_swaps_24h();
}
inline void WalletHeuristics::_internal_set_swaps_24h(uint32_t value) {
  
  _impl_.swaps_24h_ = value;
}
inline void WalletHeuristics::set_swaps_24h(uint32_t value) {
  _internal_set_swaps_24h(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.swaps_24h)
}

// uint32 swaps_7d = 5;
inline void WalletHeuristics::clear_swaps_7d() {
  _impl_.swaps_7d_ = 0u;
}
inline uint32_t WalletHeuristics::_internal_swaps_7d() const {
  return _impl_.swaps_7d_;
}
inline uint32_t WalletHeuristics::swaps_7d() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.swaps_7d)
  return _internal_swaps_7d();
}
inline void WalletHeuristics::_internal_set_swaps_7d(uint32_t value) {
  
  _impl_.swaps_7d_ = value;
}
inline void WalletHeuristics::set_swaps_7d(uint32_t value) {
  _internal_set_swaps_7d(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.swaps_7d)
}

// bool is_fresh = 6;
inline void WalletHeuristics::clear_is_fresh() {
  _impl_.is_fresh_ = false;
}
inline bool WalletHeuristics::_internal_is_fresh() const {
  return _impl_.is_fresh_;
}
inline bool WalletHeuristics::is_fresh() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.is_fresh)
  return _internal_is_fresh();
}
inline void WalletHeuristics::_internal_set_is_fresh(bool value) {
  
  _impl_.is_fresh_ = value;
}
inline void WalletHeuristics::set_is_fresh(bool value) {
  _internal_set_is_fresh(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.is_fresh)
}

// bool is_sniper = 7;
inline void WalletHeuristics::clear_is_sniper() {
  _impl_.is_sniper_ = false;
}
inline bool WalletHeuristics::_internal_is_sniper() const {
  return _impl_.is_sniper_;
}
inline bool WalletHeuristics::is_sniper() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.is_sniper)
  return _internal_is_sniper();
}
inline void WalletHeuristics::_internal_set_is_sniper(bool value) {
  
  _impl_.is_sniper_ = value;
}
inline void WalletHeuristics::set_is_sniper(bool value) {
  _internal_set_is_sniper(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.is_sniper)
}

// float bundled_pct = 8;
inline void WalletHeuristics::clear_bundled_pct() {
  _impl_.bundled_pct_ = 0;
}
inline float WalletHeuristics::_internal_bundled_pct() const {
  return _impl_.bundled_pct_;
}
inline float WalletHeuristics::bundled_pct() const {
  // @@protoc_insertion_point(field_get:dex.sol.v1.WalletHeuristics.bundled_pct)
  return _internal_bundled_pct();
}
inline void WalletHeuristics::_internal_set_bundled_pct(float value) {
  
  _impl_.bundled_pct_ = value;
}
inline void WalletHeuristics::set_bundled_pct(float value) {
  _internal_set_bundled_pct(value);
  // @@protoc_insertion_point(field_set:dex.sol.v1.WalletHeuristics.bundled_pct)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace sol
}  // namespace dex

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dex_2fsol_2fv1_2fcore_2eproto
