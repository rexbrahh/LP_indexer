---
title: "ingestor/common/slot_cache.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`ingestor/common/slot_cache.go` defines a small, thread-safe **slot → timestamp cache** abstraction (`SlotTimeCache`) and provides an in-memory implementation (`MemorySlotTimeCache`).

It’s used to attach wall-clock time to slot-based events when the upstream stream provides:

- a reliable **slot number** (always)
- a **block time** for some update types (e.g. block meta)
- but not necessarily a timestamp on every derived event we publish (e.g. swap events)

## Why this file exists

Multiple parts of the pipeline need the same “slot → timestamp” lookup:

- decoders use it to annotate swap events with a best-known timestamp
- sinks may use it to recover timestamps when events arrive without one

Making this an interface:

- keeps ingestion code decoupled from a specific cache implementation
- allows future implementations (persistent, bounded LRU, shared across processes)
- makes replay/backfill logic explicit via a “replay marker” concept

## Full source

```go title="ingestor/common/slot_cache.go" file=<rootDir>/ingestor/common/slot_cache.go showLineNumbers
```

## Walkthrough (by declaration)

### package common

```go title="package common" file=<rootDir>/ingestor/common/slot_cache.go#L1-L1 showLineNumbers
```

**What:** Declares the `common` package for ingestor/shared helpers.

**How:** This package is imported by ingest sources (Geyser/Helius) and decoders to share small utilities like caches and canonical conversions.

**Why:** These helpers sit “between” ingest sources and publishers; keeping them in `ingestor/common` prevents duplication and keeps coupling low.

### imports

```go title="imports" file=<rootDir>/ingestor/common/slot_cache.go#L3-L7 showLineNumbers
```

**What:** Standard library building blocks for error formatting, concurrency, and timestamps.

**How:** The in-memory cache uses a `sync.RWMutex` to protect a `map[uint64]time.Time`, and returns human-readable errors via `fmt.Errorf`.

**Why:** The cache is accessed from long-running goroutines; correctness requires concurrency safety.

### type (SlotTimeCache)

**Symbols:** SlotTimeCache

```go title="type (SlotTimeCache)" file=<rootDir>/ingestor/common/slot_cache.go#L9-L41 showLineNumbers
```

**What:** `SlotTimeCache` is the interface that the rest of the ingestor/decoder code depends on.

**How:** It defines:

- basic CRUD (`Get`, `Set`, `Clear`, `Size`)
- a convenience method for bulk reads (`GetRange`)
- replay helpers (`SetReplayMarker`, `GetReplayMarker`, `IsReplaySlot`)
- pruning (`PruneBeforeSlot`) to control memory growth

**Why:** A narrow interface makes it easy to swap implementations and easy to test components that depend on “time for slot”.

### type (MemorySlotTimeCache)

**Symbols:** MemorySlotTimeCache

```go title="type (MemorySlotTimeCache)" file=<rootDir>/ingestor/common/slot_cache.go#L43-L48 showLineNumbers
```

**What:** `MemorySlotTimeCache` is the simplest `SlotTimeCache` implementation: an in-memory map protected by a RW mutex.

**How:** It stores:

- `slots`: `map[uint64]time.Time` of known timestamps
- `replayMarker`: a slot boundary used to tag “replayed” slots

**Why:** This is fast, dependency-free, and good enough for single-process ingestion in local dev and many deployments.

### func NewMemorySlotTimeCache

**Symbols:** NewMemorySlotTimeCache

```go title="func NewMemorySlotTimeCache" file=<rootDir>/ingestor/common/slot_cache.go#L50-L56 showLineNumbers
```

**What:** Constructs a new `SlotTimeCache` backed by `MemorySlotTimeCache`.

**How:** Allocates an empty map and initializes the replay marker to 0 (“no replay”).

**Why:** Callers often want a ready-to-use cache without caring about the concrete type.

### func (*MemorySlotTimeCache) Get

**Symbols:** Get

```go title="func (*MemorySlotTimeCache) Get" file=<rootDir>/ingestor/common/slot_cache.go#L58-L68 showLineNumbers
```

**What:** Retrieves a timestamp for a given slot.

**How:** Uses a read lock (`RLock`) and returns an error if the slot is not present in the map.

**Why:** Treating “missing slot” as an error makes it explicit when timestamps are unknown; callers can decide how to handle unknown time (e.g. use 0 / omit).

### func (*MemorySlotTimeCache) Set

**Symbols:** Set

```go title="func (*MemorySlotTimeCache) Set" file=<rootDir>/ingestor/common/slot_cache.go#L70-L75 showLineNumbers
```

**What:** Stores a slot→timestamp mapping.

**How:** Uses an exclusive lock (`Lock`) and writes into the map.

**Why:** Updates can occur concurrently with reads from other goroutines; the lock prevents races.

### func (*MemorySlotTimeCache) GetRange

**Symbols:** GetRange

```go title="func (*MemorySlotTimeCache) GetRange" file=<rootDir>/ingestor/common/slot_cache.go#L77-L89 showLineNumbers
```

**What:** Retrieves all known timestamps for a slot range `[startSlot, endSlot]`.

**How:** Iterates slots from `startSlot` through `endSlot` and returns a new map containing only slots that exist in the cache.

**Why:** Useful for small range queries (e.g. building time windows) without requiring callers to issue many `Get` calls.

:::note
This implementation assumes `startSlot <= endSlot`. Passing an inverted range with unsigned integers can lead to unexpectedly long loops.
:::

### func (*MemorySlotTimeCache) SetReplayMarker

**Symbols:** SetReplayMarker

```go title="func (*MemorySlotTimeCache) SetReplayMarker" file=<rootDir>/ingestor/common/slot_cache.go#L91-L96 showLineNumbers
```

**What:** Marks a slot as a replay boundary.

**How:** Stores the marker under an exclusive lock.

**Why:** Replay/backfill code can use this to distinguish “live” traffic from “replayed” slots (for example, to tag events or adjust pruning).

### func (*MemorySlotTimeCache) GetReplayMarker

**Symbols:** GetReplayMarker

```go title="func (*MemorySlotTimeCache) GetReplayMarker" file=<rootDir>/ingestor/common/slot_cache.go#L98-L103 showLineNumbers
```

**What:** Returns the current replay marker.

**How:** Reads `replayMarker` under a read lock.

**Why:** Exposes the marker to any component that needs to apply “replay-aware” behavior.

### func (*MemorySlotTimeCache) IsReplaySlot

**Symbols:** IsReplaySlot

```go title="func (*MemorySlotTimeCache) IsReplaySlot" file=<rootDir>/ingestor/common/slot_cache.go#L105-L110 showLineNumbers
```

**What:** Checks whether a slot is at or after the replay marker.

**How:** Returns `true` when `replayMarker > 0` and `slot >= replayMarker`.

**Why:** Makes it easy to conditionally handle reprocessed data without duplicating marker logic at every call site.

### func (*MemorySlotTimeCache) Clear

**Symbols:** Clear

```go title="func (*MemorySlotTimeCache) Clear" file=<rootDir>/ingestor/common/slot_cache.go#L112-L118 showLineNumbers
```

**What:** Clears the cache and resets replay state.

**How:** Replaces the slots map with a fresh empty map and sets the replay marker back to 0.

**Why:** Useful for tests and for “hard reset” operations during reconnections or service restarts.

### func (*MemorySlotTimeCache) Size

**Symbols:** Size

```go title="func (*MemorySlotTimeCache) Size" file=<rootDir>/ingestor/common/slot_cache.go#L120-L125 showLineNumbers
```

**What:** Returns the number of cached slots.

**How:** Returns `len(c.slots)` under a read lock.

**Why:** A cheap health/diagnostics signal (e.g. “is the cache being populated?”).

### func (*MemorySlotTimeCache) PruneBeforeSlot

**Symbols:** PruneBeforeSlot

```go title="func (*MemorySlotTimeCache) PruneBeforeSlot" file=<rootDir>/ingestor/common/slot_cache.go#L127-L140 showLineNumbers
```

**What:** Deletes cache entries for slots older than a given boundary.

**How:** Iterates over the map keys and deletes any slot `< slot`, returning the count pruned.

**Why:** Prevents unbounded memory growth in long-running processes.
