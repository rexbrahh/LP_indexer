---
title: "ingestor/geyser/client.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`ingestor/geyser/client.go` implements a Yellowstone Geyser **gRPC streaming client** with:

- TLS + per-RPC token authentication
- automatic reconnect with backoff
- a small replay window on reconnect (to reduce missed updates)

It exposes a simple, channel-based API:

- `Subscribe(startSlot) -> (<-chan *SubscribeUpdate, <-chan error)`

## Why this file exists

Ingestion is long-running and network-dependent. A robust client needs to:

- handle transient disconnects without manual restarts
- resume near the last processed slot
- keep subscription filters consistent across reconnects

Centralizing this logic in a single client implementation keeps the service loop (`service.go`) focused on “consume updates → decode → publish”.

## Full source

```go title="ingestor/geyser/client.go" file=<rootDir>/ingestor/geyser/client.go showLineNumbers
```

## Walkthrough (by declaration)

### package geyser

```go title="package geyser" file=<rootDir>/ingestor/geyser/client.go#L1-L1 showLineNumbers
```

**What:** Declares the Yellowstone Geyser ingestion package.

**How:** The package provides a client (`Client`) that produces `SubscribeUpdate` messages and higher-level services that turn those updates into canonical events.

**Why:** Geyser-specific transport code should be isolated from decoder/sink logic so it can be swapped or combined with fallbacks.

### imports

```go title="imports" file=<rootDir>/ingestor/geyser/client.go#L3-L15 showLineNumbers
```

**What:** Dependencies for gRPC streaming, TLS authentication, reconnection timing, and logging.

**How:** `grpc`/`credentials`/`keepalive` establish and maintain the connection; `io` is used to detect clean stream EOF; `pb` is the Yellowstone protobuf contract.

**Why:** The client is essentially “dial + subscribe + recv loop”; these imports are the primitives for that lifecycle.

### const (ReconnectBackoff, ReplaySlotWindow)

**Symbols:** ReconnectBackoff, ReplaySlotWindow

```go title="const (ReconnectBackoff, ReplaySlotWindow)" file=<rootDir>/ingestor/geyser/client.go#L17-L22 showLineNumbers
```

**What:** Constants controlling reconnect behavior.

**How:**

- `ReplaySlotWindow` defines how many slots to rewind on reconnect.
- `ReconnectBackoff` defines the sleep between reconnect attempts.

**Why:** Slot-based replay reduces the chance of missing updates during a disconnect, and a fixed backoff prevents tight retry loops when the upstream is down.

### type (tokenAuth)

**Symbols:** tokenAuth

```go title="type (tokenAuth)" file=<rootDir>/ingestor/geyser/client.go#L24-L27 showLineNumbers
```

**What:** Per-RPC credentials implementation for `x-token` authentication.

**How:** `grpc.WithPerRPCCredentials(tokenAuth{token: ...})` calls into this type for every request, attaching a header map.

**Why:** Yellowstone Geyser endpoints commonly authenticate using an `x-token` header rather than mTLS or static IP allowlists.

### func (tokenAuth) GetRequestMetadata

**Symbols:** GetRequestMetadata

```go title="func (tokenAuth) GetRequestMetadata" file=<rootDir>/ingestor/geyser/client.go#L29-L31 showLineNumbers
```

**What:** Supplies request metadata for authenticated gRPC calls.

**How:** Returns `map[string]string{"x-token": <token>}`.

**Why:** This is how the Geyser endpoint receives the API key on every streaming call.

### func (tokenAuth) RequireTransportSecurity

**Symbols:** RequireTransportSecurity

```go title="func (tokenAuth) RequireTransportSecurity" file=<rootDir>/ingestor/geyser/client.go#L33-L35 showLineNumbers
```

**What:** Declares that these credentials require TLS.

**How:** Returns `true`, causing gRPC to refuse sending the header over an insecure connection.

**Why:** API keys must not be transmitted in cleartext.

### type (Client)

**Symbols:** Client

```go title="type (Client)" file=<rootDir>/ingestor/geyser/client.go#L37-L44 showLineNumbers
```

**What:** `Client` wraps a Yellowstone gRPC connection and manages subscription lifecycle.

**How:** It stores:

- validated `*Config` (endpoint, token, program filters)
- a `*grpc.ClientConn` + generated `pb.GeyserClient`
- an internal `context.Context` + `cancel` used to stop the subscribe loop

**Why:** The client is long-lived and needs explicit lifecycle control (connect, subscribe, cancel, close).

### func NewClient

**Symbols:** NewClient

```go title="func NewClient" file=<rootDir>/ingestor/geyser/client.go#L46-L58 showLineNumbers
```

**What:** Validates configuration and constructs a client with its own cancellable context.

**How:** Calls `cfg.Validate()`, then creates `context.WithCancel(context.Background())` which is used by dial and the subscribe goroutine.

**Why:** Separating client lifecycle from a caller’s request context makes it easier for services to own shutdown behavior cleanly.

### func (*Client) Connect

**Symbols:** Connect

```go title="func (*Client) Connect" file=<rootDir>/ingestor/geyser/client.go#L60-L83 showLineNumbers
```

**What:** Establishes the gRPC connection to the configured endpoint.

**How:** Dials with:

- TLS transport credentials
- keepalive pings (works even without an active stream)
- a large max receive size (1GB) to tolerate large updates
- per-RPC `x-token` authentication

On success it initializes the generated `pb.GeyserClient`.

**Why:** Connection parameters have a big impact on long-running streaming reliability; keeping them centralized ensures consistent behavior across binaries.

### func (*Client) Subscribe

**Symbols:** Subscribe

```go title="func (*Client) Subscribe" file=<rootDir>/ingestor/geyser/client.go#L85-L93 showLineNumbers
```

**What:** Starts a background goroutine that manages the subscription and returns read-only channels.

**How:** Allocates a buffered update channel and a single-slot error channel, then runs `subscribeLoop(startSlot, ...)` in a goroutine.

**Why:** The service loop can `select` on updates/errors without having to manage reconnect logic itself.

### func (*Client) subscribeLoop

**Symbols:** subscribeLoop

```go title="func (*Client) subscribeLoop" file=<rootDir>/ingestor/geyser/client.go#L95-L162 showLineNumbers
```

**What:** Implements the “subscribe, recv, reconnect” loop for the client.

**How:** On each iteration it:

1. Computes a replay slot:
   - `replaySlot = currentSlot - ReplaySlotWindow` (bounded at 0)
2. Builds a `SubscribeRequest` for `replaySlot`.
3. Opens a subscription stream (`client.Subscribe(ctx)`) and sends the request.
4. Calls `processStream` to forward `Recv()` updates into the update channel.
5. Updates `currentSlot` using the highest slot observed.
6. Sleeps `ReconnectBackoff` and repeats.

Errors are forwarded on `errCh` but the loop keeps trying unless the context is cancelled.

**Why:** Streaming connections can end for many transient reasons (network blips, upstream deploys). A dedicated loop with replay reduces data gaps while avoiding manual operational intervention.

### func (*Client) buildSubscribeRequest

**Symbols:** buildSubscribeRequest

```go title="func (*Client) buildSubscribeRequest" file=<rootDir>/ingestor/geyser/client.go#L164-L195 showLineNumbers
```

**What:** Constructs the Yellowstone subscription request used by the client.

**How:** It:

- creates an account filter entry per configured program ID (`Owner: [programID]`)
- subscribes to slot and block-meta updates (`Slots` and `BlocksMeta`)
- uses `CommitmentLevel_CONFIRMED`
- sets `FromSlot` to the requested start slot

**Why:** Filters are part of the ingest contract: they control which programs/accounts are observed and therefore which swaps can be decoded.

:::note
The request currently leaves the `Transactions` filter map empty. Depending on Yellowstone server behavior, this may result in no transaction updates. If swap decoding appears idle, this is a key place to verify/adjust.
:::

### func (*Client) processStream

**Symbols:** processStream

```go title="func (*Client) processStream" file=<rootDir>/ingestor/geyser/client.go#L197-L232 showLineNumbers
```

**What:** Receives updates from the server stream and forwards them to the update channel.

**How:** Repeatedly calls `stream.Recv()` until EOF or error:

- on EOF: returns the highest slot observed so far
- on error: sends an error to `errCh` and returns
- on success: extracts the slot from the update, updates `lastSlot`, then sends the update on `updateCh`

**Why:** Separating “recv loop” from “reconnect loop” keeps responsibilities clear and makes it easier to test slot tracking behavior.

### func extractSlotFromUpdate

**Symbols:** extractSlotFromUpdate

```go title="func extractSlotFromUpdate" file=<rootDir>/ingestor/geyser/client.go#L234-L250 showLineNumbers
```

**What:** Extracts a slot number from any of the update variants.

**How:** Switches on the `SubscribeUpdate` oneof and returns the appropriate slot field; returns 0 for unknown/unsupported types.

**Why:** Slot tracking drives reconnection and replay decisions; this helper centralizes that logic.

### func (*Client) Close

**Symbols:** Close

```go title="func (*Client) Close" file=<rootDir>/ingestor/geyser/client.go#L252-L259 showLineNumbers
```

**What:** Stops the client and closes the underlying gRPC connection.

**How:** Cancels the client context and closes the `grpc.ClientConn` (if present).

**Why:** Ensures that background goroutines exit and resources are released on shutdown.

### func (*Client) Name

**Symbols:** Name

```go title="func (*Client) Name" file=<rootDir>/ingestor/geyser/client.go#L261-L263 showLineNumbers
```

**What:** Returns a stable name for this ingest source.

**How:** Always returns `"geyser"`.

**Why:** The failover controller and metrics label sources by name.
