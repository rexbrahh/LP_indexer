---
title: "ingestor/helius/client.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`ingestor/helius/client.go` implements a higher-level Helius ingestor client that
turns upstream `pb.SubscribeUpdate` messages into a **canonical update stream**
for the rest of the pipeline.

It:

- manages the lifecycle of an underlying `streamClient` (LaserStream gRPC)
- feeds account + block meta into the shared swap decoder
- decodes swap transactions into `dexv1.SwapEvent`
- emits canonical updates as a small union type (`Update`)
- tracks coarse health signals (`HealthSnapshot`) for failover/monitoring

## Why this file exists

The failover story benefits from a provider client that can answer:

- “are we currently receiving updates?”
- “what is the latest slot observed?”
- “what kind of canonical events can we produce?”

This wrapper client exists to:

- hide upstream protobuf details from downstream consumers
- standardize the output into a small, typed set of canonical messages
- provide a simple health snapshot for controllers/dashboards

## Full source

```go title="ingestor/helius/client.go" file=<rootDir>/ingestor/helius/client.go showLineNumbers
```

## Walkthrough (by declaration)

### package helius

```go title="package helius" file=<rootDir>/ingestor/helius/client.go#L1-L1 showLineNumbers
```

**What:** Declares the `helius` ingestion package.

**How:** This file defines a high-level client that consumes provider updates and emits canonical `dexv1` messages via an `Update` channel.

**Why:** Keeping provider-specific code in one package prevents it from leaking into decoders/sinks and makes failover composition easier.

### imports

```go title="imports" file=<rootDir>/ingestor/helius/client.go#L3-L14 showLineNumbers
```

**What:** Dependencies for canonical protobuf messages, shared decoding, and concurrency control.

**How:** Uses `swapdecoder` for swap decoding, `common.ConvertTxMeta` for canonical tx meta, and a mutex to safely publish health snapshots.

**Why:** The client owns concurrent goroutines (run loop + callers reading health), so state needs synchronization.

### type (Update)

**Symbols:** Update

```go title="type (Update)" file=<rootDir>/ingestor/helius/client.go#L16-L22 showLineNumbers
```

**What:** Canonical union container for emitted updates.

**How:** Exactly one pointer field should be non-nil:

- `BlockHead` for slot→time/finality context
- `TxMeta` for tx-wide metadata (logs, CU usage)
- `Swap` for decoded swap events

**Why:** This keeps the outbound channel type stable and minimal while still allowing multiple canonical message kinds to flow through the same pipeline.

### type (HealthSnapshot)

**Symbols:** HealthSnapshot

```go title="type (HealthSnapshot)" file=<rootDir>/ingestor/helius/client.go#L24-L35 showLineNumbers
```

**What:** Coarse health information about the client’s current streaming status.

**How:** Fields capture:

- `LastHeartbeat`: time of last successful message
- `LastSlot`: highest slot seen
- `Healthy`: whether the client currently considers itself live
- `Source`: which channel is producing updates (currently `"grpc"`)

**Why:** Failover controllers and dashboards need a simple signal, not detailed stream internals.

### type (Client)

**Symbols:** Client

```go title="type (Client)" file=<rootDir>/ingestor/helius/client.go#L37-L49 showLineNumbers
```

**What:** `Client` owns the lifecycle of Helius connections and produces canonical updates.

**How:** It stores:

- validated `*Config`
- a mutex-protected `HealthSnapshot`
- a shared `swapdecoder.Decoder` instance (slot timestamps + pool metadata)
- a cancel function for stopping the run loop
- `newStream`: injectable constructor for the underlying gRPC stream client (for tests)

**Why:** The client needs to manage internal goroutines and expose health safely to callers.

### type (streamClient)

**Symbols:** streamClient

```go title="type (streamClient)" file=<rootDir>/ingestor/helius/client.go#L51-L55 showLineNumbers
```

**What:** Interface for the underlying upstream stream implementation.

**How:** Matches the minimal lifecycle needed by `run`: connect, subscribe, close.

**Why:** Allows dependency injection (e.g. fake streams in tests) and decouples the wrapper client from a concrete gRPC implementation.

### func NewClient

**Symbols:** NewClient

```go title="func NewClient" file=<rootDir>/ingestor/helius/client.go#L57-L72 showLineNumbers
```

**What:** Validates configuration and constructs a high-level Helius client.

**How:** Initializes:

- `health.Healthy = false`
- a new swap decoder (`swapdecoder.New(nil)` creates its own slot cache)
- `newStream` to construct a real `StreamClient` by default

**Why:** Construction is the right time to fail fast on missing endpoints/API keys before starting background goroutines.

### func (*Client) Start

**Symbols:** Start

```go title="func (*Client) Start" file=<rootDir>/ingestor/helius/client.go#L74-L85 showLineNumbers
```

**What:** Starts streaming and returns update + error channels.

**How:** Creates a derived context with `context.WithCancel`, stores the cancel on the client, and runs `c.run(...)` in a goroutine.

**Why:** The caller can cancel the stream via `Close()` and can consume canonical updates via channels without owning reconnect logic.

### func (*Client) Close

**Symbols:** Close

```go title="func (*Client) Close" file=<rootDir>/ingestor/helius/client.go#L87-L96 showLineNumbers
```

**What:** Stops the client and releases resources.

**How:** Cancels the stored run-loop context (if present) under a mutex.

**Why:** Safe-to-call shutdown simplifies integration with services and tests.

### func (*Client) Health

**Symbols:** Health

```go title="func (*Client) Health" file=<rootDir>/ingestor/helius/client.go#L98-L103 showLineNumbers
```

**What:** Returns a copy of the current health snapshot.

**How:** Reads `c.health` under a read lock.

**Why:** Exposes health safely to other goroutines without leaking internal synchronization details.

### func (*Client) setHealth

**Symbols:** setHealth

```go title="func (*Client) setHealth" file=<rootDir>/ingestor/helius/client.go#L105-L109 showLineNumbers
```

**What:** Internal helper for mutating health under a lock.

**How:** Executes a caller-provided function while holding the write lock.

**Why:** Keeps health updates concise and reduces repeated lock/unlock boilerplate.

### func (*Client) setCancel

**Symbols:** setCancel

```go title="func (*Client) setCancel" file=<rootDir>/ingestor/helius/client.go#L111-L115 showLineNumbers
```

**What:** Stores the current run-loop cancel function.

**How:** Writes `c.cancel` under a mutex.

**Why:** Allows `Close()` to stop the running goroutine reliably.

### func (*Client) run

**Symbols:** run

```go title="func (*Client) run" file=<rootDir>/ingestor/helius/client.go#L117-L191 showLineNumbers
```

**What:** Main run loop that owns the upstream stream lifecycle and emits canonical updates.

**How:** The loop:

1. Constructs the underlying `streamClient` (by default `NewStreamClient`).
2. Connects and subscribes starting from `startSlot`.
3. Marks health as healthy and sets `Source = "grpc"`.
4. Selects over:
   - context cancellation → mark unhealthy and exit
   - upstream errors → mark unhealthy, forward error
   - upstream updates → update `LastHeartbeat`/`LastSlot`, then call `handleSubscribeUpdate`

**Why:** Separating this loop from the concrete gRPC client makes it easy to add additional sources (e.g. WebSocket) in the future while preserving the same canonical output.

### func (*Client) handleSubscribeUpdate

**Symbols:** handleSubscribeUpdate

```go title="func (*Client) handleSubscribeUpdate" file=<rootDir>/ingestor/helius/client.go#L193-L227 showLineNumbers
```

**What:** Translates an upstream `SubscribeUpdate` into zero or more canonical `Update` messages.

**How:** Handles relevant update types:

- **Block meta**:
  - feeds the decoder (`decoder.HandleBlockMeta`)
  - emits a canonical `dexv1.BlockHead` (`Status = "confirmed"`, `TsSec` when present)
- **Account**:
  - feeds the decoder (`decoder.HandleAccount`) to cache pool metadata
- **Transaction**:
  - emits a canonical `TxMeta` via `common.ConvertTxMeta`
  - decodes swaps via `decoder.DecodeTransaction` and emits each swap event

All other update types are ignored.

**Why:** This is the boundary where provider-specific updates become provider-agnostic canonical protobuf messages.

### func (*Client) sendUpdate

**Symbols:** sendUpdate

```go title="func (*Client) sendUpdate" file=<rootDir>/ingestor/helius/client.go#L229-L234 showLineNumbers
```

**What:** Sends an `Update` on the output channel while respecting cancellation.

**How:** Uses a `select` between `out <- update` and `ctx.Done()`.

**Why:** Prevents goroutine leaks when the caller stops consuming updates or the context is cancelled.

### func slotFromUpdate

**Symbols:** slotFromUpdate

```go title="func slotFromUpdate" file=<rootDir>/ingestor/helius/client.go#L236-L251 showLineNumbers
```

**What:** Extracts a slot number from any of the update variants.

**How:** Switches on the update oneof and returns the appropriate slot field; returns 0 for unknown variants.

**Why:** Slot tracking drives health reporting and allows operators/controllers to see progress.
