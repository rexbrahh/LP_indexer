---
title: "decoder/common/fixed_point.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`decoder/common/fixed_point.go` contains numeric helpers used by CLMM decoders:

- Q64.64 fixed-point conversions for sqrt prices
- tick ↔ sqrt price conversions (using the `1.0001` tick base)
- token amount scaling/unscaling by decimals
- simple spot-price computation from swap amounts

## Why this file exists

Several DEXes in this repo (Raydium CLMM, Orca Whirlpools) represent prices as
sqrt prices in Q64.64 fixed-point format.

Centralizing conversions:

- prevents each decoder from re-implementing tricky numeric logic
- makes it easier to audit correctness and precision tradeoffs
- standardizes how we derive float prices/volumes for analytics and debugging

## Full source

```go title="decoder/common/fixed_point.go" file=<rootDir>/decoder/common/fixed_point.go showLineNumbers
```

## Walkthrough (by declaration)

### package common

```go title="package common" file=<rootDir>/decoder/common/fixed_point.go#L1-L1 showLineNumbers
```

**What:** Declares the `decoder/common` helper package.

**How:** Decoder implementations import this package for shared math and normalization logic.

**Why:** Keeping shared numeric utilities in one place reduces duplication and improves consistency across decoders.

### imports

```go title="imports" file=<rootDir>/decoder/common/fixed_point.go#L3-L7 showLineNumbers
```

**What:** Dependencies for fixed-point arithmetic and floating point math.

**How:** `math/big` is used for 128-bit-ish fixed-point operations; `math` provides sqrt/pow/log helpers; `fmt` formats parse errors.

**Why:** CLMM price representations often exceed native integer widths; big integers avoid overflow when parsing and scaling.

### const (Q64Shift)

**Symbols:** Q64Shift

```go title="const (Q64Shift)" file=<rootDir>/decoder/common/fixed_point.go#L9-L13 showLineNumbers
```

**What:** Bit-width of the fractional component in Q64.64 numbers.

**How:** Q64.64 encodes values as `integer << 64 + fractional`, so scaling by `2^64` is the core operation.

**Why:** Having this as a named constant keeps conversions self-documenting.

### var (Q64One)

**Symbols:** Q64One

```go title="var (Q64One)" file=<rootDir>/decoder/common/fixed_point.go#L15-L17 showLineNumbers
```

**What:** `Q64One` represents `1 << 64` as a `big.Int`.

**How:** Created via `big.NewInt(1)` shifted left by `Q64Shift`.

**Why:** Used as a divisor/multiplier when converting between Q64.64 integer representations and real values.

### func SqrtPriceQ64ToFloat

**Symbols:** SqrtPriceQ64ToFloat

```go title="func SqrtPriceQ64ToFloat" file=<rootDir>/decoder/common/fixed_point.go#L19-L41 showLineNumbers
```

**What:** Converts a Q64.64 sqrt price (encoded as a decimal string) into a float64 price.

**How:**

1. Parses the string into a `big.Int` (base 10).
2. Converts to `big.Float` for division.
3. Divides by `2^64` to obtain the real-valued sqrt price.
4. Squares the result to get price: `price = (sqrtPrice / 2^64)^2`.
5. Converts to `float64`.

**Why:** CLMM state typically stores sqrt price. Squaring after scaling yields a conventional spot price useful for logs, dashboards, and downstream derivations.

### func FloatToSqrtPriceQ64

**Symbols:** FloatToSqrtPriceQ64

```go title="func FloatToSqrtPriceQ64" file=<rootDir>/decoder/common/fixed_point.go#L43-L58 showLineNumbers
```

**What:** Converts a float64 price into a Q64.64 sqrt price string.

**How:** Computes `sqrt(price) * 2^64`, converts the result to an integer (`big.Int`), and returns its decimal string form.

**Why:** Useful for tests, fixtures, and for “round-tripping” between human-friendly prices and on-chain representations.

### func TickIndexToSqrtPrice

**Symbols:** TickIndexToSqrtPrice

```go title="func TickIndexToSqrtPrice" file=<rootDir>/decoder/common/fixed_point.go#L60-L79 showLineNumbers
```

**What:** Converts a tick index to a Q64.64 sqrt price string.

**How:** Uses the standard CLMM tick base `1.0001` and computes:

`sqrt_price = 1.0001^(tick/2) * 2^64`

The implementation uses float math (`math.Pow`) and then scales into Q64.64.

**Why:** Tick indices are a common CLMM representation; this helper makes it easy to derive comparable sqrt prices across systems.

### func SqrtPriceToTickIndex

**Symbols:** SqrtPriceToTickIndex

```go title="func SqrtPriceToTickIndex" file=<rootDir>/decoder/common/fixed_point.go#L81-L103 showLineNumbers
```

**What:** Converts a Q64.64 sqrt price string into the nearest tick index.

**How:** Parses and scales the sqrt price back to a real number, then computes:

`tick = floor( ln(sqrt_price) / ln(1.0001) * 2 )`

**Why:** Some analytics want tick-space representations (e.g. for liquidity distribution) rather than raw sqrt price values.

### func ScaleAmount

**Symbols:** ScaleAmount

```go title="func ScaleAmount" file=<rootDir>/decoder/common/fixed_point.go#L105-L109 showLineNumbers
```

**What:** Scales a raw integer token amount into “human units” using decimals.

**How:** Divides by `10^decimals`.

**Why:** Prices/volumes are easier to interpret and compare when amounts are expressed in natural units instead of raw integer base units.

### func UnscaleAmount

**Symbols:** UnscaleAmount

```go title="func UnscaleAmount" file=<rootDir>/decoder/common/fixed_point.go#L111-L115 showLineNumbers
```

**What:** Converts a scaled float amount back into raw token units.

**How:** Multiplies by `10^decimals` and casts to `uint64` (truncating any fractional remainder).

**Why:** Useful for tests and for converting derived values back into integer form when needed.

### func CalculatePriceFromAmounts

**Symbols:** CalculatePriceFromAmounts

```go title="func CalculatePriceFromAmounts" file=<rootDir>/decoder/common/fixed_point.go#L117-L128 showLineNumbers
```

**What:** Computes an effective quote/base price from swap amounts and decimals.

**How:** Scales the raw amounts and returns `scaledB / scaledA`. Returns 0 when `amountA` is zero.

**Why:** Sometimes the most reliable price signal is the observed swap exchange rate rather than a pool’s reported sqrt price.
