---
title: "decoder/raydium/instruction.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`decoder/raydium/instruction.go` defines Raydium CLMM program constants and the
core data structures used to decode Raydium swap instructions:

- `SwapInstruction`: decoded binary instruction payload
- `SwapEvent`: normalized “what happened” view used by higher layers

It also includes a small parser (`ParseSwapInstruction`) for the raw instruction
byte layout.

## Why this file exists

Raydium CLMM swaps are encoded as compact binary instruction payloads.

This file exists to:

- keep the binary layout and parsing logic in one place
- provide typed structures that higher-level decoders can consume safely
- standardize the fields that downstream systems care about (amounts, direction, sqrt price)

## Full source

```go title="decoder/raydium/instruction.go" file=<rootDir>/decoder/raydium/instruction.go showLineNumbers
```

## Walkthrough (by declaration)

### package raydium

```go title="package raydium" file=<rootDir>/decoder/raydium/instruction.go#L1-L1 showLineNumbers
```

**What:** Declares the Raydium decoder package.

**How:** Other packages call `ParseSwapInstruction` and `ParseSwapEvent` (in `parser.go`) to decode swaps from transaction data.

**Why:** Keeping Raydium-specific parsing isolated prevents program layout details from leaking into the generic ingestion pipeline.

### imports

```go title="imports" file=<rootDir>/decoder/raydium/instruction.go#L3-L6 showLineNumbers
```

**What:** Dependencies for decoding binary instruction payloads.

**How:** `encoding/binary` reads little-endian integers from the instruction bytes; `fmt` formats parse errors.

**Why:** Raydium instruction data is a packed byte array; decoding requires precise endian-aware reads.

### const (ProgramID)

**Symbols:** ProgramID

```go title="const (ProgramID)" file=<rootDir>/decoder/raydium/instruction.go#L8-L9 showLineNumbers
```

**What:** The on-chain program ID for Raydium CLMM swaps.

**How:** Used by the ingest decoder to route instructions/accounts to the correct decoder logic.

**Why:** Program IDs are the canonical way to identify which on-chain program produced an instruction.

### type (SwapInstruction)

**Symbols:** SwapInstruction

```go title="type (SwapInstruction)" file=<rootDir>/decoder/raydium/instruction.go#L11-L29 showLineNumbers
```

**What:** In-memory representation of a decoded Raydium CLMM swap instruction payload.

**How:** Captures:

- an 8-byte discriminator (copied from the payload prefix)
- amount and threshold fields (`u64`)
- a sqrt price limit encoded as a 128-bit Q64.64 fixed-point value (stored here as two `u64`s)
- a direction flag (`IsBaseInput`)

**Why:** The raw byte layout is not convenient to work with. Converting it to a struct makes downstream decoding and validation clearer and less error-prone.

### type (SwapEvent)

**Symbols:** SwapEvent

```go title="type (SwapEvent)" file=<rootDir>/decoder/raydium/instruction.go#L31-L62 showLineNumbers
```

**What:** Canonical-ish swap event model for Raydium swaps (still decoder-local).

**How:** Contains:

- pool/mint identifiers and decimals
- raw swap amounts (`AmountIn`, `AmountOut`)
- fee info (`FeeBps`)
- sqrt price fields (Q64.64 as low/high parts)
- direction (`IsBaseInput`)
- transaction context (slot, signature, timestamp)

**Why:** Higher layers (ingest decoder, publishers) want a stable “swap happened” structure, regardless of instruction parsing details.

### func ParseSwapInstruction

**Symbols:** ParseSwapInstruction

```go title="func ParseSwapInstruction" file=<rootDir>/decoder/raydium/instruction.go#L64-L86 showLineNumbers
```

**What:** Parses raw instruction bytes into a `SwapInstruction`.

**How:** Validates minimum length (41 bytes), then reads:

- discriminator (8 bytes)
- amount (u64)
- other amount threshold (u64)
- sqrt price limit (two u64s)
- base-input flag (1 byte)

**Why:** This is the low-level boundary between “opaque bytes” and “typed fields”. Bounds checks prevent panics and make decode failures explicit.

### func (*SwapInstruction) SqrtPriceX64

**Symbols:** SqrtPriceX64

```go title="func (*SwapInstruction) SqrtPriceX64" file=<rootDir>/decoder/raydium/instruction.go#L88-L92 showLineNumbers
```

**What:** Convenience accessor for the u128 sqrt price limit value.

**How:** Returns the `(low, high)` u64 parts.

**Why:** Keeps callers from directly referencing struct fields and clarifies intent (“treat these two u64s as one fixed-point value”).
