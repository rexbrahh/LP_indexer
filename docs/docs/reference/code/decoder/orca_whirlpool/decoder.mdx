---
title: "decoder/orca_whirlpool/decoder.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`decoder/orca_whirlpool/decoder.go` implements an Orca Whirlpool swap decoder.

It takes as input:

- a raw swap instruction payload (bytes)
- account lists and balance snapshots
- Whirlpool pool state before/after the swap

and produces a normalized `SwapEvent` including:

- swap direction + amounts
- sqrt price / tick / liquidity before and after
- canonical base/quote orientation and derived price/volume

## Why this file exists

Orca Whirlpool is a CLMM (concentrated liquidity) DEX. Decoding swaps generally
requires more than just the instruction bytes — pool state and token decimals
matter for correct price/volume interpretation.

This decoder exists to:

- isolate Orca-specific instruction and state layout knowledge
- provide a normalized swap event model for ingestion/publishing
- keep the rest of the pipeline DEX-agnostic

## Full source

```go title="decoder/orca_whirlpool/decoder.go" file=<rootDir>/decoder/orca_whirlpool/decoder.go showLineNumbers
```

## Walkthrough (by declaration)

### package orca_whirlpool

```go title="package orca_whirlpool" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L1-L1 showLineNumbers
```

**What:** Declares the Orca Whirlpool decoder package.

**How:** The main entrypoint is `(*Decoder) DecodeSwapTransaction(...)`.

**Why:** Encapsulates Orca-specific logic behind a clean API so higher-level ingestion code can treat all DEXes uniformly.

### imports

```go title="imports" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L3-L10 showLineNumbers
```

**What:** Dependencies for instruction parsing, fixed-point conversions, and token metadata lookup.

**How:** Uses:

- `bytes`/`encoding/binary` to decode binary instruction layouts
- `decoder/common` for sqrt price conversion and base/quote determination
- `time` for timestamped swap events

**Why:** CLMM decoding combines binary parsing with numeric interpretation and token metadata.

### type (Decoder)

**Symbols:** Decoder

```go title="type (Decoder)" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L12-L15 showLineNumbers
```

**What:** Orca Whirlpool swap decoder instance.

**How:** Holds a `common.MintMetadataProvider`, which supplies mint decimals (and symbols for canonical ordering).

**Why:** Decimals are required to scale amounts and compute prices/volumes consistently.

### func NewDecoder

**Symbols:** NewDecoder

```go title="func NewDecoder" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L17-L22 showLineNumbers
```

**What:** Constructs a decoder with the provided mint metadata provider.

**How:** Stores the provider on the decoder struct.

**Why:** Separates token metadata lookup from decode logic and makes the decoder testable (providers can be stubbed).

### func (*Decoder) DecodeSwapTransaction

**Symbols:** DecodeSwapTransaction

```go title="func (*Decoder) DecodeSwapTransaction" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L24-L162 showLineNumbers
```

**What:** Decodes an Orca Whirlpool swap from instruction bytes + contextual transaction/pool state.

**How:** The function:

1. Validates the instruction discriminator (first 8 bytes) matches `SwapInstructionDiscriminator`.
2. Decodes the rest of the instruction via `decodeSwapInstruction`.
3. Extracts the pool address from the accounts list (by convention, index 2).
4. Requires both pre- and post-swap pool state snapshots (to compute price/tick/liquidity changes).
5. Computes realized swap amounts using `calculateAmounts` (based on balance deltas).
6. Looks up token decimals for mint A/B via the metadata provider.
7. Determines canonical base/quote ordering via `common.DetermineBaseQuote`.
8. Converts the post-swap sqrt price (Q64.64 string) into a float price.
9. Computes normalized base/quote volumes and a base/quote-oriented price.
10. Computes fee and protocol fee amounts from the input amount and configured fee rates.

Returns a populated `SwapEvent` on success.

**Why:** Orca swaps are CLMM swaps: direction, amounts, and price are best interpreted when you combine instruction flags with balance deltas and pool state.

### func decodeSwapInstruction

**Symbols:** decodeSwapInstruction

```go title="func decodeSwapInstruction" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L164-L207 showLineNumbers
```

**What:** Decodes the swap instruction payload after the 8-byte discriminator.

**How:** Reads fields in little-endian order:

- amount (u64)
- other amount threshold (u64)
- sqrt price limit (u128 → 16 bytes → string)
- `amount_specified_is_input` (bool byte)
- `a_to_b` (bool byte)

**Why:** Binary decoding is the first step in turning an instruction into a semantic swap event.

### func (*Decoder) calculateAmounts

**Symbols:** calculateAmounts

```go title="func (*Decoder) calculateAmounts" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L209-L241 showLineNumbers
```

**What:** Computes `amountIn` and `amountOut` by comparing pre/post balance snapshots.

**How:** Assumes a “typical” Orca swap account ordering and uses hard-coded indices into `preBalances`/`postBalances`:

- for A→B: input is user token A decrease, output is user token B increase
- for B→A: input is user token B decrease, output is user token A increase

Returns an error when there are not enough balance entries.

**Why:** Balance deltas are often more reliable than instruction payload amounts for determining realized swap quantities.

:::note
This helper currently assumes a specific account/balance indexing scheme and does not use the `accounts` slice. If Orca instruction layouts vary, this is the first place that may need to be generalized.
:::

### func calculateFeeAmount

**Symbols:** calculateFeeAmount

```go title="func calculateFeeAmount" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L243-L248 showLineNumbers
```

**What:** Computes the fee amount taken from the input amount.

**How:** Applies the basis-point fee rate: `(amountIn * feeRate) / 10000`.

**Why:** Fee amounts are useful for analytics and can be compared against pool state transitions.

### func calculateProtocolFee

**Symbols:** calculateProtocolFee

```go title="func calculateProtocolFee" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L250-L255 showLineNumbers
```

**What:** Computes the protocol fee portion from the total fee.

**How:** Applies basis points to the fee amount: `(feeAmount * protocolFeeRate) / 10000`.

**Why:** Distinguishing LP fee vs protocol fee can matter in revenue analytics and for validating pool accounting.

### func bytesToU128String

**Symbols:** bytesToU128String

```go title="func bytesToU128String" file=<rootDir>/decoder/orca_whirlpool/decoder.go#L257-L281 showLineNumbers
```

**What:** Converts a 16-byte little-endian u128 value to a string representation.

**How:** Extracts low/high 64-bit parts and formats:

- `low` when `high == 0`
- otherwise uses a simplified formatting strategy that concatenates `high` and padded `low`

**Why:** Some Whirlpool instruction fields (like sqrt price limits) are u128-sized. Representing them as strings avoids overflow in native Go integer types.

:::caution
The current implementation is explicitly described as simplified and does not perform a true base-10 u128 conversion when `high != 0`. For fully correct conversion, use `math/big`.
:::
