---
title: "bridge/service.go"
---

This page is an **annotated source reference**. Code blocks are imported from the repository at build time.

## What this file is

`bridge/service.go` implements the long-running **JetStream → JetStream forwarder** used during cutovers.

At a high level it:

- connects to a **source** NATS/JetStream and inspects a source stream’s subjects
- creates durable pull consumers and continuously **fetches** messages (manual ack)
- maps subjects via `SubjectMapper` (rewrite / drop)
- publishes messages to a **target** JetStream stream using `ExpectStream`
- optionally exposes Prometheus metrics via an HTTP endpoint

## Why this file exists

The canonical pipeline (ingest → decode → publish → sinks/API) is designed to be stable and forward-looking.
Legacy consumers often need a different subject namespace (or they should not receive certain events at all) while the cutover is in progress.

This file keeps that migration-specific behavior isolated:

- core components don’t need to know about legacy subjects
- ops can roll out mappings/drops without modifying ingestor/decoder logic
- forwarding is explicit, observable (metrics), and failure modes are clear (no ack until publish succeeds)

## Full source

```go title="bridge/service.go" file=<rootDir>/bridge/service.go showLineNumbers
```

## Walkthrough (by declaration)

### package bridge

```go title="package bridge" file=<rootDir>/bridge/service.go#L1-L1 showLineNumbers
```

**What:** Declares the `bridge` package that hosts the forwarding service.

**How:** The `cmd/bridge` binary imports `bridge` to construct a `Service` and run it with a context.

**Why:** Keeping the bridge runtime in a reusable package makes it easier to test and keeps the entrypoint thin.

### imports

```go title="imports" file=<rootDir>/bridge/service.go#L3-L18 showLineNumbers
```

**What:** Dependencies for JetStream I/O, metrics, and concurrency control.

**How:**

- `nats.go` provides NATS connection + JetStream APIs (pull consumers, publish, metadata).
- `errgroup` coordinates goroutines with cancellation on first error.
- `prometheus`/`promauto`/`promhttp` provide metrics registration and HTTP exposition.
- stdlib packages cover contexts, timing, HTTP server, string sanitization, and error handling.

**Why:** The bridge is primarily “I/O plumbing”: it needs robust cancellation, correct ack/publish semantics, and optional observability without introducing complicated dependencies.

### type (SubjectMapper)

**Symbols:** SubjectMapper

```go title="type (SubjectMapper)" file=<rootDir>/bridge/service.go#L20-L23 showLineNumbers
```

**What:** A function that decides how to translate an incoming subject into a subject to publish to, or to drop the message entirely.

**How:** The bridge calls `mapper(msg.Subject)` for each message:

- return `(mapped, true)` to publish to `mapped`
- return `("", false)` to drop (ack the source, do not publish)

**Why:** Cutovers often require selective translation/dropping, and expressing it as a function keeps the forwarding loop simple and testable.

### type (Option)

**Symbols:** Option

```go title="type (Option)" file=<rootDir>/bridge/service.go#L25-L26 showLineNumbers
```

**What:** Functional option used to customize `Service` construction.

**How:** `New(cfg, opts...)` applies each non-nil `Option` to the `Service` before final validation (defaults, mapper setup, metrics).

**Why:** Options let `cmd/bridge` (or tests) override behavior (custom mapper, custom metrics registry) without exploding the constructor signature.

### const (defaultFetchBatch, defaultFetchWait, defaultPublishTimeout)

**Symbols:** defaultFetchBatch, defaultFetchWait, defaultPublishTimeout

```go title="const (defaultFetchBatch, defaultFetchWait, defaultPublishTimeout)" file=<rootDir>/bridge/service.go#L28-L32 showLineNumbers
```

**What:** Default knobs for pull-based consumption and publish timeouts.

**How:**

- `defaultFetchBatch` controls how many messages are fetched per pull request.
- `defaultFetchWait` is the long-poll wait used with `nats.MaxWait`; timeouts are treated as “no messages right now”.
- `defaultPublishTimeout` bounds how long a publish is allowed to block.

**Why:** These defaults balance throughput (batching) with responsiveness to shutdown (short waits) and avoid indefinite publish hangs.

### type (Service)

**Symbols:** Service

```go title="type (Service)" file=<rootDir>/bridge/service.go#L34-L44 showLineNumbers
```

**What:** Holds bridge configuration and runtime dependencies for forwarding.

**How:** Key fields:

- `cfg`: validated `bridge.Config` (URLs, streams, mappings, metrics addr).
- `mapper`: subject translator (`SubjectMapper`), defaulting to identity.
- `fetchBatch`/`fetchWait`: pull-consumer fetch tuning.
- `publishTimeout`: timeout applied to target publishes.
- `metrics`: optional Prometheus instruments; `metricsServer` controls bind address.

**Why:** Centralizing these knobs in a struct keeps the run loop deterministic and makes it possible to construct the same service from different entrypoints or tests.

### func New

**Symbols:** New

```go title="func New" file=<rootDir>/bridge/service.go#L46-L89 showLineNumbers
```

**What:** Constructs a `Service` from config and options, applying defaults and performing validation.

**How:** The constructor:

1. Validates `cfg` early (`cfg.Validate()`).
2. Seeds a `Service` with defaults (identity mapper, fetch/publish defaults, metrics addr).
3. Applies options (custom mapper, custom metrics registerer, custom metrics server addr, etc.).
4. If no custom mapper was provided and `cfg.SubjectMappings` is non-empty, compiles mappings via `mapperFromMappings`.
5. Ensures required runtime invariants:
   - `mapper` is not nil
   - `metrics` is not nil (creates an isolated registry by default)
   - fetch/publish settings are sane

The result is a ready-to-run service.

**Why:** The bridge should be boring to operate: centralized validation prevents surprises (nil mapper, bad fetch settings) and keeps runtime failures focused on connectivity and JetStream behavior.

### func WithSubjectMapper

**Symbols:** WithSubjectMapper

```go title="func WithSubjectMapper" file=<rootDir>/bridge/service.go#L91-L99 showLineNumbers
```

**What:** Option to supply a custom subject mapping function.

**How:** When `mapper` is non-nil it:

- sets `s.mapper` to the provided mapper
- marks `s.customMapper = true` so config-file mappings (`cfg.SubjectMappings`) won’t override it

**Why:** This enables programmatic or test-specific mapping logic without depending on YAML files.

### func WithMetricsRegisterer

**Symbols:** WithMetricsRegisterer

```go title="func WithMetricsRegisterer" file=<rootDir>/bridge/service.go#L101-L108 showLineNumbers
```

**What:** Option to control where bridge metrics are registered and how they’re gathered.

**How:** It sets `s.metrics` using `newServiceMetrics(reg, gatherer)`, which ensures a consistent pair of `(Registerer, Gatherer)`:

- if both are nil, it creates an isolated in-memory registry (safe default)
- if only one is provided, it attempts to derive the other when possible

**Why:** Prometheus registries are global-ish; using an isolated registry by default avoids “duplicate metric registration” panics in tests or multi-tenant binaries.

### func WithMetricsServer

**Symbols:** WithMetricsServer

```go title="func WithMetricsServer" file=<rootDir>/bridge/service.go#L110-L117 showLineNumbers
```

**What:** Option to configure (or override) the HTTP address where metrics are exposed.

**How:** It sets `s.metricsServer` (e.g. `:9090`). If empty, the bridge will not start a metrics HTTP server.

**Why:** Some environments expose metrics via sidecars or separate endpoints; making the server optional keeps the bridge deployable in more contexts.

### func (*Service) Run

**Symbols:** Run

```go title="func (*Service) Run" file=<rootDir>/bridge/service.go#L119-L202 showLineNumbers
```

**What:** Runs the bridge until the context is canceled or an unrecoverable error occurs.

**How:** The run loop is:

1. Default `ctx` to `context.Background()` if nil.
2. Connect to **source** and **target** NATS servers (`nats.Connect`).
3. Create JetStream contexts for both connections.
4. Fetch source stream info and extract its configured subject list.
5. Start an `errgroup` for lifecycle management.
6. Optionally start a Prometheus HTTP server (`promhttp.HandlerFor`) if `metricsServer` is configured.
7. For each subject in the source stream:
   - derive a durable consumer name (`durableName(subject)`)
   - create a pull subscription bound to the source stream with manual ack
   - start a goroutine that loops `consumeLoop`
8. Wait for all goroutines; normalize `context.Canceled` on shutdown.

The bridge uses **manual ack** and only acknowledges source messages after either:

- the message is intentionally dropped by the mapper, or
- the publish to the target stream succeeds.

**Why:** This structure provides at-least-once forwarding with clear backpressure and shutdown semantics, while keeping the bridge logic explicit and observable.

### func (*Service) Config

**Symbols:** Config

```go title="func (*Service) Config" file=<rootDir>/bridge/service.go#L204-L207 showLineNumbers
```

**What:** Exposes the service configuration.

**How:** Returns the stored `cfg` value by copy (the struct itself is returned).

**Why:** Access to effective config is useful for debugging, tests, or logging without re-reading environment variables.

### func (*Service) consumeLoop

**Symbols:** consumeLoop

```go title="func (*Service) consumeLoop" file=<rootDir>/bridge/service.go#L209-L232 showLineNumbers
```

**What:** Continuously fetches messages from a pull subscription and forwards them to the target.

**How:**

- It checks `ctx.Err()` on each iteration for responsive shutdown.
- `sub.Fetch(batch, nats.MaxWait(wait))` long-polls for up to `fetchWait`.
- `nats.ErrTimeout` is treated as “no messages”; the loop simply continues.
- Every fetched message is passed to `s.forward(...)`; the first error stops the loop (and cancels the errgroup).

**Why:** Fetching in bounded batches keeps the bridge efficient while still responsive to cancellation and supports high-throughput subject forwarding.

### func (*Service) forward

**Symbols:** forward

```go title="func (*Service) forward" file=<rootDir>/bridge/service.go#L234-L281 showLineNumbers
```

**What:** Forwards a single source JetStream message to the target stream, applying subject mapping and metrics.

**How:**

1. If metrics are enabled, it tries to compute source lag via `msg.Metadata().Timestamp`.
2. It maps the subject via `s.mapper`:
   - if `ok=false`, it counts a drop and `Ack()`s the source message.
3. It constructs a new `nats.Msg` with the mapped subject and copies the payload and headers.
4. It publishes with:
   - a derived context from `publishContext` (timeout)
   - `nats.ExpectStream(s.cfg.TargetStream)` to ensure the publish lands in the intended stream
5. On publish error:
   - it increments publish error metrics
   - it returns `context.Canceled` when cancellation was the cause
6. On success, it `Ack()`s the original source message and increments forwarded metrics.

If publishing fails, the source message is not acknowledged, so JetStream will redeliver it (at-least-once semantics).

**Why:** This function is the correctness boundary: it enforces “don’t ack unless forwarded or intentionally dropped” and centralizes metrics so the rest of the loop stays simple.

### func (*Service) publishContext

**Symbols:** publishContext

```go title="func (*Service) publishContext" file=<rootDir>/bridge/service.go#L283-L288 showLineNumbers
```

**What:** Creates a publish context with an optional timeout.

**How:** If `publishTimeout <= 0`, it returns the parent context and a no-op cancel. Otherwise it returns `context.WithTimeout(parent, publishTimeout)`.

**Why:** Publishing should not hang indefinitely; a timeout bounds latency and ensures the service can shut down promptly under failure conditions.

### func collectSubjects

**Symbols:** collectSubjects

```go title="func collectSubjects" file=<rootDir>/bridge/service.go#L290-L298 showLineNumbers
```

**What:** Extracts the configured subject list from a JetStream stream config.

**How:** If `cfg.Subjects` is non-empty, it returns a copy of that slice; otherwise it returns nil.

**Why:** Returning a copy avoids accidental mutation of the stream config object and makes the bridge’s subject list explicit.

### func defaultSubjectMapper

**Symbols:** defaultSubjectMapper

```go title="func defaultSubjectMapper" file=<rootDir>/bridge/service.go#L300-L302 showLineNumbers
```

**What:** The identity subject mapper.

**How:** Returns `(subject, true)` meaning “publish to the same subject; do not drop”.

**Why:** Most of the time the bridge forwards without transformation; an identity mapper is a simple and explicit default.

### func durableName

**Symbols:** durableName

```go title="func durableName" file=<rootDir>/bridge/service.go#L304-L321 showLineNumbers
```

**What:** Derives a JetStream durable consumer name from a subject string.

**How:** It:

- replaces characters that are common in subjects but awkward in durable names (`.`, `*`, `>`, space, `:`) with `_`
- trims leading/trailing `_`
- falls back to `all` if the result is empty
- truncates to 64 characters
- prefixes with `bridge_` for namespace clarity

**Why:** The bridge creates one durable pull consumer per subject; durable names must be stable, valid, and bounded in length to avoid JetStream naming issues.

### func cloneHeader

**Symbols:** cloneHeader

```go title="func cloneHeader" file=<rootDir>/bridge/service.go#L323-L334 showLineNumbers
```

**What:** Deep-copies an incoming NATS header map.

**How:** It allocates a new `nats.Header` and copies each slice of values so the published message does not share backing arrays with the source message.

**Why:** Defensive copying avoids accidental mutation/aliasing bugs when messages are forwarded across connections and goroutines.

### type (serviceMetrics)

**Symbols:** serviceMetrics

```go title="type (serviceMetrics)" file=<rootDir>/bridge/service.go#L336-L342 showLineNumbers
```

**What:** Bundles the Prometheus instruments used by the bridge.

**How:** It tracks:

- counters for forwarded messages, dropped messages, and publish errors (labelled by subject)
- a gauge for “source lag” in seconds (labelled by subject)
- the `Gatherer` used to expose metrics via HTTP

**Why:** Metrics provide operational confidence during cutover: you want to know what’s being forwarded, what’s being dropped, and whether the bridge is keeping up.

### func newServiceMetrics

**Symbols:** newServiceMetrics

```go title="func newServiceMetrics" file=<rootDir>/bridge/service.go#L344-L400 showLineNumbers
```

**What:** Creates a `serviceMetrics` instance and ensures a consistent registry/gatherer pairing.

**How:** It handles three cases:

- neither `reg` nor `gatherer` provided → create a new `prometheus.Registry` and use it for both
- only `reg` provided → derive a `Gatherer` when possible; otherwise fall back to `prometheus.DefaultGatherer`
- only `gatherer` provided → derive a `Registerer` when possible; otherwise create a new `prometheus.Registry`

It then registers:

- `forwarded`, `dropped`, and `publishErr` counters
- a `sourceLag` gauge

All metrics use the `dex_bridge_*` namespace/subsystem and names defined in `observability`.

**Why:** Metric registration is a common source of friction in tests and multi-binary repos; this helper makes metric wiring deterministic and keeps the service code focused on forwarding.

### func (*serviceMetrics) incForwarded

**Symbols:** incForwarded

```go title="func (*serviceMetrics) incForwarded" file=<rootDir>/bridge/service.go#L402-L404 showLineNumbers
```

**What:** Increments the “forwarded” counter for a subject.

**How:** Calls `CounterVec.WithLabelValues(subject).Inc()`.

**Why:** Counting forwards by subject makes it easy to verify cutover progress and detect unexpected routing.

### func (*serviceMetrics) incDropped

**Symbols:** incDropped

```go title="func (*serviceMetrics) incDropped" file=<rootDir>/bridge/service.go#L406-L408 showLineNumbers
```

**What:** Increments the “dropped” counter for a subject.

**How:** Calls `CounterVec.WithLabelValues(subject).Inc()` when the mapper returns `ok=false`.

**Why:** Drops are often intentional during cutover, but you still want to observe their rate and which subjects are being suppressed.

### func (*serviceMetrics) incPublishError

**Symbols:** incPublishError

```go title="func (*serviceMetrics) incPublishError" file=<rootDir>/bridge/service.go#L410-L412 showLineNumbers
```

**What:** Increments the “publish errors” counter for a mapped subject.

**How:** Called when `targetJS.PublishMsg` returns a non-nil error.

**Why:** Publish failures are the main cause of backpressure and redelivery; tracking them highlights target-side issues quickly.

### func (*serviceMetrics) observeLag

**Symbols:** observeLag

```go title="func (*serviceMetrics) observeLag" file=<rootDir>/bridge/service.go#L414-L416 showLineNumbers
```

**What:** Updates the “source lag” gauge for a subject.

**How:** Sets the gauge to the computed lag in seconds (`time.Since(metadata.Timestamp)`), clamped to non-negative values.

**Why:** Lag is the simplest “are we keeping up?” signal; it helps differentiate “no messages” from “messages but the bridge is behind”.
